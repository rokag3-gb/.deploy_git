<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SQL PASS Korea 세미나 발표 - Azure SQL database의 Geo Replica와 Managed Instance의 Failover group을 통한 CQRS 구현</title>
    <link href="/2023/03/sql-pass-korea-seminar/"/>
    <url>/2023/03/sql-pass-korea-seminar/</url>
    
    <content type="html"><![CDATA[<h1 id="도입"><a href="#도입" class="headerlink" title="도입"></a>도입</h1><p>2023년2월 경 시퀄로 김정선 이사님께 내가 “발표할 일 있음 연락주세요” 말씀 드렸다가 막상 “발표해보시겠어요?” 제안 받으니까 걱정되고 두렵다. 비록 나는 DB 전문가는 아니지만 무장적 해보기로 했다. (어떻게든 되겠지ㅎ)</p><h1 id="세미나-정보"><a href="#세미나-정보" class="headerlink" title="세미나 정보"></a>세미나 정보</h1><p><a href="https://onoffmix.com/event/270849">SQL PASS Korea 세미나 시즌2 - 신청 페이지</a></p><p>![SQL PASS Korea 세미나 시즌2 세션 목차](img&#x2F;sql-pass-korea-seminar-2023-03&#x2F;onoffmix - table of contents.png)</p><ul><li><p>등록 및 교류시간 (PM 1:30 ~ 2:00)</p></li><li><p>SQL PASS Korea 소개 (발표자 김정선 @ PASS Korea Leader)</p></li><li><p>세션-1: Azure SQL database Geo Replica, 또는 Managed Instance의 Failover group을 통한 CQRS 구현 (50분), 김정우 ㈜클라우드메이트<br><br><code>(Level 100) Azure SQL database의 Geo Replica, 또는 Managed Instance의 Failover group을 통해 RW와 Readonly를 간편하게 구성할 수 있습니다. WAS에서 Command(CUD)는 RW로 요청하고, Query(R)는 Readonly로 요청하여 CQRS 패턴을 구현합니다.</code></p></li><li><p>세션-2: SQL Server 2022 차세대 Intelligent Query Processing (50분), 김정선 ㈜씨퀄로<br><br><code>(Level 300)SQL Server 2022의 새로운 기능 중 쿼리 성능 관점에서 핵심이 되는 Intelligent Query Processing(IQP)의 차세대 기능들을 소개합니다. SQL Server 2022로 업그레이드를 준비 중이거나 계획 중인 분들과 SQL Server 기술에 관심 있는 분들에게 도움이 될 것입니다.</code></p></li><li><p>세션-3: SQL Server 2022 Engine Innovations (50분), 김영건 (주)씨퀄로<br><br><code>(Level 200)SQL Server 2022 Engine의 발전된 기능들과 확장된 T-SQL 기능들을 소개합니다. SQL Server 2022로 업그레이드를 준비 중이거나 계획 중인 분들과 SQL Server 기술에 관심 있는 분들에게 도움이 될 것입니다.</code></p></li><li><p>이벤트 &amp; Q&#x2F;A (당일 상황에 따라 변동될 수 있습니다)</p></li></ul><h1 id="세션-주요-내용"><a href="#세션-주요-내용" class="headerlink" title="세션 주요 내용"></a>세션 주요 내용</h1><p>Architecture comparison - Azure SQL Database Geo Replica VS Failover group</p><h1 id="스냅-사진"><a href="#스냅-사진" class="headerlink" title="스냅 사진"></a>스냅 사진</h1><p><img src="/img/sql-pass-korea-seminar-2023-03/KakaoTalk_20230917_205807945_04_down.jpg"></p><p><img src="/img/sql-pass-korea-seminar-2023-03/KakaoTalk_20230917_205807945_05_down.jpg"></p><p><img src="/img/sql-pass-korea-seminar-2023-03/KakaoTalk_20230917_205807945_06_down.jpg"></p><p><img src="/img/sql-pass-korea-seminar-2023-03/KakaoTalk_20230917_205807945_20.jpg"></p><p><img src="/img/sql-pass-korea-seminar-2023-03/KakaoTalk_20230917_205807945_18.jpg"></p><h1 id="발표자료"><a href="#발표자료" class="headerlink" title="발표자료"></a>발표자료</h1>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Azure SQL</tag>
      
      <tag>Managed Instance</tag>
      
      <tag>Geo Replica</tag>
      
      <tag>Failover</tag>
      
      <tag>PASS Korea</tag>
      
      <tag>Failover Group</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>생동감 있는 개발 조직에서 격변의 시간을 보낸 틀딱 개발자의 2022년 회고</title>
    <link href="/2022/12/2022-retrospect/"/>
    <url>/2022/12/2022-retrospect/</url>
    
    <content type="html"><![CDATA[<h1 id="도입"><a href="#도입" class="headerlink" title="도입"></a>도입</h1><p>2022년은 나에게 하나의 새로운 시도였고 흥미진진했고 역동적이었다. SNS 상에 많은 분들 회고 글을 보면서 ‘나도 써볼까? 잼있겠는데?’ 생각만 했었는데 올해부터는 나도 회고 글 쓰는 사람이 되어보려고 한다.</p><h1 id="새-술은-새-부대에"><a href="#새-술은-새-부대에" class="headerlink" title="새 술은 새 부대에"></a>새 술은 새 부대에</h1><p>신규 팀을 빌드하였다. 2020 ~ 2021년까지는 Lead Engineering 조직 내에서 SW 개발 일을 했었고 2022년부터는 보다 전문적이고 집중적으로 Service Development 하기 위해 참여 의사가 있는 크루들을 모으고 신규 팀을 만들어달라고 회사에 요청했고 결국 <code>서비스개발팀</code>이 만들어졌다. (두둥딱)</p><p><img src="/img/retrospect-2022-12/20221021_104901.jpg"><br><em>Hype Driven Development (설레발 주도 개발)의 문제점에 대해서 토론하는 모습</em></p><br><p>클라우드메이트에 입사하고 난 후부터 사내 또는 고객사에 적절한 애플리케이션을 서비스하여 생산성을 끌어올릴 수 있겠다는 생각을 많이 했었고, 나 혼자만의 생각들이 실제 실무자들에게 필요한 것인지 검증하기 위해 사내 여러 동료들로부터 어떤 애플리케이션이 업무 상 필요한지 디스커션을 많이 하면서 정보를 모았다. 그런 과정을 통해서 2022년 서비스개발팀이 해야할 일에 대해서 경영진에게 보고하고 재가를 받았다. 일을 크게 벌려놓고는 항상 근심이 많다.</p><blockquote><p><code>서비스개발팀</code>에서 해야할 일들은 다음과 같았다.</p><ol><li>신규 서비스 런칭</li></ol><ul><li>IAM 서비스</li><li>영업관리 서비스 (이하 SalesOps)</li><li>챗봇 서비스 (이하 Colson[콜슨])</li></ul><ol start="2"><li>캐시 엔진 솔루션 개발</li><li>기존 애플리케이션 유지보수</li><li>고객사 애플리케이션 개발</li><li>고객사 개발 컨설팅</li><li>개발 경험 사내, 사외 전파</li></ol></blockquote><h1 id="신규-서비스-런칭"><a href="#신규-서비스-런칭" class="headerlink" title="신규 서비스 런칭"></a>신규 서비스 런칭</h1><h2 id="IAM-Identity-and-Access-Management"><a href="#IAM-Identity-and-Access-Management" class="headerlink" title="IAM (Identity and Access Management)"></a>IAM (Identity and Access Management)</h2><p><img src="/img/retrospect-2022-12/IAM_Login_UI.png"></p><p>사내 임직원 뿐만 아니라 OAuth2.0 통해서 외부 고객사에서도 사용할 수 있는 계정 및 권한 관리 시스템이 꼭 필요했다. 그래서 IAM 서비스부터 개발하였고 KeyCloak과 Hashicorp Vault를 사용해서 사용자, 역할, 권한, 시크릿을 관리할 수 있는 웹애플리케이션을 출시했다. 이 과정에서 RBAC (Roll Base Access Control) 에 대해 깊이 고민 후 적용하게 되었고, OAuth2.0은 반드시 HTTPS 연결을 해야겠다고 판단했다.</p><h2 id="SalesOps"><a href="#SalesOps" class="headerlink" title="SalesOps"></a>SalesOps</h2><p><img src="/img/retrospect-2022-12/SalesOps_UI.png"></p><p>IAM 출시 이후에 바로 이어서 SalesOps라고 하는 영업관리 웹애플리케이션 개발에 착수하였다. SalesOps는 영업 조직의 업무를 효율화하고 fileless한 업무 환경으로 가기 위해서 시작하였고, SalesOps에는 영업 관련된 기능과 CRM 일부 기능이 포함되어 2022년 12월까지 CBT(Closed Beta Test)를 진행했고 2023년 초에 정식으로 프로덕션하기 위해 막바지 작업이 한참이다.</p><h2 id="Colson"><a href="#Colson" class="headerlink" title="Colson"></a>Colson</h2><p>SalesOps를 개발하면서 동시에 Colson(콜슨) 챗봇 개발 역시 진행했다. Colson은 사내 다양한 질의응답, 재택&#x2F;휴가 여부, 주변 식당 검색 등 을 챗봇을 통하여 빠르고 간편하게 확인할 수 있게 하기 위하여 기획하였다. Colson은 Teams 메신저 상에서 이용할 수 있는 챗봇이며 9월에 서비스를 시작하여 식당 조회, 근무지(재택,휴가,외근) 등록 및 조회, 생일자 복지 알림, 익명 칭찬 메시지 전달, 기술지원 업무 알림 등 다양한 서비스를 제공하고 있다. 클라우드메이트 구성원들로부터 좋은 평가를 받고 있다고 나는 생각한다. (과연..?)</p><p><img src="/img/retrospect-2022-12/Colson_UI.png"></p><hr><p>신규 3가지 서비스를 런칭하면서 느꼈던 점은 굉장히 많은데 조금 요약하자면, 하나의 서비스를 최초 기획, 최종 오픈할 때까지 정말 많은 구성원들에게 서비스 소개를 자주 해야 했었다. 나는 최대한 쉽게 풀어서 설명하려고 했으나 나의 설명 능력 부족으로 인해 듣는 사람은 다르게 해석하거나 그 서비스를 다른 시각에서 바라보는 경우가 많았다. 그래서 “이건 이런 서비스에요. 추가로 원하는게 있나요? 만들어드릴께요.” 형태의 대화를 정말 많이 했다. 추가적으로 이건 “가장 큰 결실”이라고 느꼈던 것은 웹 풀스택에 걸쳐서 클라우드메이트 만의 웹 개발 기준 프레임워크를 (아직 부족하지만) 제시했다는 거다. 이제 이 기준 프레임워크에 맞추어 다양한 서비스 또는 기능 추가를 조금 더 단시간에 적은 노력으로 할 수 있는 기틀을 마련했다고 생각한다.</p><h1 id="좋았던-점"><a href="#좋았던-점" class="headerlink" title="좋았던 점"></a>좋았던 점</h1><p>개인적으로 2022년 가장 큰 즐거움은 팀 크루 10명이 어떻게 하면 즐겁게 일 할 수 있을까? 에 대해서 깊이 고민하고 즐겁고 경쾌하게 서로 업무할 수 있는 환경이 어느 정도는 만들어진 것 같아 그 점이 가장 좋은 기억으로 남는다. 항상 나에게 기술적 조언과 경험 전달을 아끼지 않고 나의 힘든 점을 보듬어주려고 애써주시는 성민님, 인자한 미소와 함께 “나도 이런거 할 수 있으니까 시켜주세요.” 라며 내 부담을 덜어주려고 하시는 원균님, KeyCloak과 프리파라, 포켓몬의 광팬이면서 다양한 부분에서 엄청난 기여를 해주신 광석님, React의 열렬한 지지자이면서 프론트엔드 개발과 프론트엔드 프로젝트의 중심을 잡아주신 그리고 종무식 때 잠시 켜졌던 카메라를 통해 cute한 땡땡이 잠옷을 보여주신 진호님, 타지에서 원격근무하면서도 항상 번뜩이는 아이디어와 개발 센스로 놀라운 퍼포먼스를 보여주시는 진혁님, Airflow를 魔개조하시고 다양한 개발언어를 넘나들며 백엔드에서 다양한 기여해주신 우분투의 신 영빈님, 묵묵히 맡은 페이지를 개발 완수해 내시며 점점 더 개발 가속도가 붙는게 보이는 우윳빛깔 예원님, 생소할 수 있는 프론트엔드 포지션에서 무서운 속도로 성장하고 계시는 효도르 a.k.a 효줌마 효연님, “닷넷이 미래다”라는 격언과 함께 MVVM XAML의 황제이면서 최근에는 REST API를 무서운 속도로 개발하고 계시는 상훈님까지.. 이건 개인의 회고이면서도 팀 구성원에게 감사한 마음을 표현하는 글이다. (수줍수줍)</p><p><img src="/img/retrospect-2022-12/20221021_145219_20.jpg"><br><em>2022년 10월경 서비스개발팀 플레이샵하러 실내 야구 경기 중 모두가 빵터진 순간</em></p><p>기술적으로는 Azure 서비스를 적극 활용해서 경험치를 쌓았고 (Container Apps 이거 좋더라.) 닷넷 애플리케이션을 리눅스에서 서빙하면서 다양한 경험을 해볼 수 있어서 좋았다.</p><h1 id="힘들었던-점"><a href="#힘들었던-점" class="headerlink" title="힘들었던 점"></a>힘들었던 점</h1><p>신규 개발과 기존 애플리케이션의 유지 보수를 오간다는 것이 내 두뇌에서 상당한 context switching cost가 발생해서, 일정 관리에 심혈을 기울였다. 종종 외근 나가서 어설픈 초식 몇가지를 선보이며 나의 경험을 표현해야 해서 꽤나 힘들었다.</p><h1 id="아쉬웠던-점"><a href="#아쉬웠던-점" class="headerlink" title="아쉬웠던 점"></a>아쉬웠던 점</h1><p>다양한 개발 환경을 적극적으로, 온전히 내 것으로 만들지 못한 것이 가장 아쉬웠던 점이다. 2023년에는 Go를 학습하여 내가 짠 Go 애플리케이션을 프로덕션 서비스에 적용해볼 생각이다. 프로젝트 매니징 관점에서는, 코드 리뷰를 활발하게 하는 문화를 정착시키지 못하고 프로덕트 출시에 급급했던 면이 있다고 생각한다. 2023년에는 코드 리뷰를 활성화 시키도록 노력할 생각이다. </p><h1 id="2023년도-계획"><a href="#2023년도-계획" class="headerlink" title="2023년도 계획"></a>2023년도 계획</h1><p>개발 조직, 문화 등 큰 기류를 흐트리지 않으면서 다양한 부분에 변화를 주어 내가 하는 일을 조금 더 엔지니어링 쪽으로 집중할 생각이다. 또한 서비스개발팀 내에 다양한 <code>셀</code> 결성을 통하여 하나의 셀 내에서 기획&#x2F;개발&#x2F;QA 를 모두 진행하는 방식으로 프로젝트 진행 방식을 바꾸어보려 한다.</p><p><img src="/img/retrospect-2022-12/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0%EC%9D%983%EC%9A%94%EC%86%8C.jpg"><br><em>2023년도에도 많은 공감, 대화, 설득이 필요할 것 같다.</em></p><p>Workflow를 관리하는 애플리케이션을 만들어서 실제 서비스에 적용해볼 생각이다. <code>Airflow, Dagster 같은 훌륭한 애플리케이션이 있는데 바퀴를 왜 재발명하는가?</code> 하는 의문이 들 수 도 있지만, 기성 OSS (Open Source SW) 보다 복잡성은 낮추고 최소한의 필요한 기능을 제공해는 형태로 만들어서 실무에 적용할 계획을 갖고 있다.</p><p>개인적으로는 큰 변화를 줘 볼 생각이다. 내 커리어에 대해서도 진지하게 고민할 생각이다. “데이터” 관련 직무로 조금 더 집중하고 싶다는 생각을 갖고 있다. VPoE (VP of Engineering) 포지션을 내가 수행할 수 있을까에 대한 고민도 하고 있다. 바쁘다는 핑계로 블로그 글을 못썼는데, 내가 주니어일 때 좋은 자료가 부족해서 힘들었던 만큼 그 시절을 떠올리며 좋은 자료를 쓰도록 노력하고자 한다.</p><hr><p>여기까지 생동감 있는 개발 조직에서 격변의 시간을 보낸 틀딱 개발자의 2022년 회고를 마친다.</p><p><img src="/img/retrospect-2022-12/KakaoTalk_20221231_160037996.jpg"><br><em>눈이 어마어마하게 내리던 어느 겨울날 눈 구경하는 모습</em></p>]]></content>
    
    
    <categories>
      
      <category>Story</category>
      
    </categories>
    
    
    <tags>
      
      <tag>회고</tag>
      
      <tag>Retrospect</tag>
      
      <tag>틀딱 개발자</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Azure SQL 의 data file size 와 IOPS 의 불편한 진실</title>
    <link href="/2021/12/azure-db-file-iops/"/>
    <url>/2021/12/azure-db-file-iops/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/azure-db-file-iops-2021-11/library.chungnam.png"></p><p>깔끔하게 정리정돈된 도서관 내부 모습은 마치, 잘 관리되고 있는 데이터베이스를 보는 것 같다. 참고로 썸네일 사진은 충남도서관이고 나랑 아무런 연관은 없다.</p><h2 id="시작하기에-앞서"><a href="#시작하기에-앞서" class="headerlink" title="시작하기에 앞서"></a>시작하기에 앞서</h2><p>우리가 클라우드 서비스를 사용하게 되면 처음에는 비싸지 않는데 이상하게 점점 더 비싸지는 느낌적인 느낌이 있다. 이에 과금 최적화 작업을 종종 진행하고는 하는데, 얼마 전에 한 account 내에서 과금 최적화를 위하여 데이터베이스 스토리지 최적화를 진행했었는데, 이때 전혀 예상치 못한 일들이 벌어졌었던 삽질 이야기를 공유하고자 글로 옮긴다.</p><h2 id="Azure-SQL-Managed-Instance-은-아주-좋은-서비스"><a href="#Azure-SQL-Managed-Instance-은-아주-좋은-서비스" class="headerlink" title="Azure SQL Managed Instance 은 아주 좋은 서비스"></a>Azure SQL Managed Instance 은 아주 좋은 서비스</h2><p>마우스 몇번의 클릭으로 PaaS DB 가 떡하니 생기고, 알아서 vnet과 subnet에 배치해주고, 알아서 public endpoint도 만들어주고, 알아서 연결 구성 만들어주고, 알아서 PITR 구성해주고, 굉장히 편리하고 좋은 서비스이다. <em><strong>(SQL Managed Instance 만세👍)</strong></em></p><p>한번 만들어놓으면 메인터넌스 할 것이 거의 없다. login 추가라던가, 쿼리 튜닝 정도 는 해줘야 겠지만, 뭐 거의 알아서 잘 돌아간다. <em><del>물론 과금도 잘 돌아간다.</del></em></p><p><img src="/img/azure-db-file-iops-2021-11/Azure_SQL_PaaS.png"></p><p><a href="https://docs.microsoft.com/ko-kr/azure/azure-sql/managed-instance/sql-managed-instance-paas-overview">MS docs - Azure SQL Managed Instance란?</a></p><h2 id="문제-상황의-등장"><a href="#문제-상황의-등장" class="headerlink" title="문제 상황의 등장"></a>문제 상황의 등장</h2><blockquote><p>어떤 DB 의 reserved storage가 640GiB이고 used storage 는 400GiB 정도였으며, used storage의 96% 가 하나의 테이블에 집중되어 있다. 이 테이블을 <strong>tbl_his</strong> 라고 부르겠다. tbl_his 에는 최근 4~5년간 히스토리 성격의 데이터가 담겨 있고, insert 만 되고 있으며 select 하는 경우는 거의 없다고 한다.</p></blockquote><hr><h2 id="내가-생각한-솔루션"><a href="#내가-생각한-솔루션" class="headerlink" title="내가 생각한 솔루션"></a>내가 생각한 솔루션</h2><p>데이터 보존 관리 정책을 수립해야겠다고 판단했다. tbl_his 에는 최근 3개월 간의 데이터만 남기고 나머지 데이터는 Azure blob storage 로 옮긴다거나, 또는 아카이브 용도의 Azure SQL single database를 아주 낮은 tier 로 생성하여, 아주 간혹 있을 select 에 대응하면 되겠다.</p><p>tbl_his 에 최근 3개월 간 데이터만 남기게 되면 mdf 의 크기는 너무 헐렁해져 있을 것이니 shrinkfile notruncate 한 이후에 shrinkfile truncateonly 하면 되겠다. 후후 좋아. 이 정도면 완벽한 플랜이고 이제 이 플랜대로 작업을 해야겠다.</p><p><img src="/img/azure-db-file-iops-2021-11/Everyone_has_a_plan.png"></p><blockquote><p>누구나 그럴듯한 계획을 갖고 있다. 쳐맞기 전까지는.<br>by 전설의 Michael Tyson 옹</p></blockquote><hr><h2 id="이제-작업을-시작해보자"><a href="#이제-작업을-시작해보자" class="headerlink" title="이제 작업을 시작해보자"></a>이제 작업을 시작해보자</h2><p>작업 순서는 아래와 같이 구성했다.</p><ul><li>tbl_his 와 동일한 구조를 갖는 tbl_his_new 테이블 생성.<br>tbl_his_new 의 년월 단위로 파티셔닝.<br><code>1900-01</code> ~ <code>2099-12</code> 까지 파일그룹 <code>n</code>개. 파일 <code>n</code>개.<br>이때 낱개의 데이터 파일은 init size 64 MiB 에 growth는 16MiB 로 설정.</li><li>tbl_his 의 최근 3개월 데이터만 tbl_his_new 테이블에 담기.</li><li>tbl_his 이름 변경 -&gt; tbl_his_old</li><li>tbl_his_new 이름 변경 -&gt; tbl_his</li><li>tbl_his_old 테이블 삭제</li><li>shrinkfile notruncate</li><li>shrinkfile truncateonly</li></ul><p>위 작업 중에서 3번과 4번은 세션이 거의 없는 시간대에 동시에 처리해야 어플리케이션 단에서 에러가 나지 않을 것이다.<br>(이른바 <em><strong>테이블 바꿔치기</strong></em> 전략)</p><p>테이블 바꿔치기 전략을 사용한 이유는, tbl_his 테이블에서 최근 3개월 데이터를 제외한 과거 데이터를 모두 delete 하는 시간 보다, tbl_his 테이블에서 최근 3개월 데이터만 별도의 테이블에 담는 시간이 훨씬 짧게 소요될 것으로 판단했기 떄문이다.</p><p>위 작업 순서대로 순조롭게 모든 작업을 마쳤고, 깔끔하게 쉬링크 된 이후의 storage utilization은 아래와 같다.<br><img src="/img/azure-db-file-iops-2021-11/storage_check.png"></p><p>used storage가 400GiB에서 196GiB으로 절반 수준으로 줄어든 모습. used storage를 많이 줄였으니 Azure portal에서 reserved storage를 많이 줄일 수 있겠군. 이제 모두가 행복해졌다.</p><hr><h2 id="장애의-시작"><a href="#장애의-시작" class="headerlink" title="장애의 시작"></a>장애의 시작</h2><p><img src="/img/azure-db-file-iops-2021-11/developer_horror.png"></p><p>메트릭을 가만히 쳐다보고 있던 나는 뭔가 섬뜩해져 오는 기분을 느꼈다. 아래 메트릭을 보자.</p><blockquote><p><em>참고로 이 account 내의 어플리케이션 환경은 .NET Core 2.1 이고 Azure App Service를 활용하여 서비스 운영 중에 있다.</em></p></blockquote><p><img src="/img/azure-db-file-iops-2021-11/metric_01.png"></p><p>App Service의 request metric이 위 그림처럼 규칙적으로 요동을 치기 시작했다.</p><p><img src="/img/azure-db-file-iops-2021-11/metric_02.png"></p><p>Azure SQL Managed Instance의 CPU % 값은 App Service의 request metric의 패턴과 일치하게 파도를 쳤고 CPU % 값이 최대 95%까지 육박하였다.</p><p><img src="/img/azure-db-file-iops-2021-11/metric_03.png"></p><p>App Service의 response time이다. Avg가 저정도인데 Max는 얼마나 높았을까.. 정말 많은 requests 가 매우 오랫동안 기다리며 응답성이 느려졌던 건데, 이 포스트를 쓰고 있는 시점에도 저 metric을 보면 심장이 두근거린다.</p><hr><h2 id="트러블슈팅"><a href="#트러블슈팅" class="headerlink" title="트러블슈팅"></a>트러블슈팅</h2><p>생각을 해보자. 해당일자에 App은 변경된 것이 없고, 변경된 것은 DB 밖에 없다. 그럼 DB에서도 무엇이 변경됐지? shrink 작업을 통해 DB의 used storage가 절반 수준으로 줄어들었고, 데이터 용량의 대부분을 차지하고 있던 tbl_his 테이블의 파티셔닝 작업을 통하여 단일 데이터 파일의 용량이 작아졌다. App의 요청량이 파도를 쳤고 요청량의 파도에 따라 DB의 CPU % 값 역시 파도를 쳤다. DB 에서의 Batch request&#x2F;sec 는 일정했으며 Active worker count가 거의 두배로 증가를 했다. 그렇다면..!</p><p><img src="/img/azure-db-file-iops-2021-11/idea_flash.png"></p><p>DB의 reserved storage 용량과 used storage 용량에 따라 보장되는 IOPS가 다른 것인가? 라는 가설에 따라 Azure portal에서 DB의 reserved storage 용량을 증설해보았다. (몇분 이내 적용 완료)</p><blockquote><p><em>흠, 그래도 상황은 나아지지 않았다.</em></p></blockquote><p>웹검색을 통하여 몇가지 새로운 인사이트를 얻을 수 있었다. Azure SQL Managed Instance에 장착되어 있는 Premium storage disk 에는 disk size 계층에 따라 각기 다른 maximum IOPS per disk 을 제공한다는 것이다.</p><p>Scalability and performance targets for VM disks<br><a href="https://docs.microsoft.com/en-us/azure/virtual-machines/disks-scalability-targets">https://docs.microsoft.com/en-us/azure/virtual-machines/disks-scalability-targets</a></p><p>Storage performance best practices and considerations for Azure SQL DB Managed Instance (General Purpose)<br><a href="https://techcommunity.microsoft.com/t5/datacat/storage-performance-best-practices-and-considerations-for-azure/ba-p/305525">https://techcommunity.microsoft.com/t5/datacat/storage-performance-best-practices-and-considerations-for-azure/ba-p/305525</a></p><p><img src="/img/azure-db-file-iops-2021-11/Premium_unmanaged_disks_Per-disk_limits.png"></p><p>tbl_his 테이블을 파티셔닝 하기 전에는 Primary 파일그룹에 담겨있었는데, 이 Primary 단일 파일에서 파티셔닝하면서 단일 data file size가 64MiB로 확 줄어들면서 해당 파일의 IOPS 가 2,300 에서 500 으로 떨어진 것으로 추정된다.</p><p>그렇다면 이번에는!<br><img src="/img/azure-db-file-iops-2021-11/idea_flash.png"></p><p>각 개별 data file size를 128GiB 보다 큰 값, 예를 들어 136GiB으로 늘려 장애 상황이 해소되는지 알아보기로 했다.</p><blockquote><p><em>오오! 문제가 해결되었다.</em></p></blockquote><p>아래 메트릭처럼 data file size를 늘리자마자 App의 requests가 일정하게 유입되는 것으로 확인된다.</p><p><img src="/img/azure-db-file-iops-2021-11/metric_normal_03.png"></p><p>아래 메트릭처럼, 11:30 AM을 기점으로 App의 response time(avg,max) 이 정상 수준으로 내려간 것이 확인된다.</p><p><img src="/img/azure-db-file-iops-2021-11/metric_normal_05.png"></p><p>또한 DB의 CPU % 역시 아래 메트릭처럼, 기존 장애 상황에서 스파이크 치던 모습에서 11:30 AM을 기점으로 스파이크가 거의 없어진 모습이 확인된다.</p><p><img src="/img/azure-db-file-iops-2021-11/metric_normal_04.png"></p><hr><h2 id="교훈"><a href="#교훈" class="headerlink" title="교훈"></a>교훈</h2><ol><li>Azure SQL Managed Instance의 IOPS는 reserved storage, used storage가 아닌 <strong>data file size</strong> 에 따라 제공된다.</li><li>과금 최적화한다고 무작정 데이터 용량을 줄였다가는 폭풍야근을 하게될 수 있다.</li><li>글자 많은 블로그라고 대충 넘기지 말고 자세히 읽어보면 그 안에 지혜가 담겨있다.</li></ol><hr><h2 id="추신"><a href="#추신" class="headerlink" title="추신"></a>추신</h2><blockquote><p><em>닷넷이 미래 입니다. (.NET 6 LTS 만세)</em></p></blockquote><p><img src="/img/azure-db-file-iops-2021-11/dotnet_is_future.png"></p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Azure SQL Managed Instance</tag>
      
      <tag>SQL Server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Azure DMS를 활용한 DB migration 에피소드</title>
    <link href="/2021/04/azure-dms-episode/"/>
    <url>/2021/04/azure-dms-episode/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/azure-dms-2021-04/Azure_DMS.png"></p><h2 id="1-Azure-Database-Migration-Service-소개"><a href="#1-Azure-Database-Migration-Service-소개" class="headerlink" title="1. Azure Database Migration Service 소개"></a>1. Azure Database Migration Service 소개</h2><p>이 글에서는 Azure DMS 에 대한 개요, 소개는 짤막하게 주요 링크들로 대체하고 DMS로 실제 마이그레이션 프로젝트를 진행했던 과정 위주로 기술하겠습니다.</p><p>Azure 안에서 소개된 내용은,</p><blockquote><p>Azure Database Migration Service는 Azure로의 데이터베이스 마이그레이션을 간소화하고, 가속화할 수 있게 도와주며, 안내하고, 자동화하는 데 도움이 되는 도구입니다.</p></blockquote><p>라고 소개되어 있습니다.</p><p><a href="https://azure.microsoft.com/ko-kr/services/database-migration">Azure 데이터베이스 마이그레이션 가이드</a><br><a href="https://docs.microsoft.com/ko-kr/azure/dms/dms-tools-matrix">데이터 마이그레이션 시나리오에 사용할 수 있는 서비스 및 도구</a></p><h2 id="2-DB-마이그레이션-계획"><a href="#2-DB-마이그레이션-계획" class="headerlink" title="2. DB 마이그레이션 계획"></a>2. DB 마이그레이션 계획</h2><p><strong>원본 DB 진단</strong></p><ul><li>AWS EC2 (IaaS)</li><li>OS: Microsoft Windows Server 2019</li><li>class: r5.4xlarge (16 vCPU, memory 128 GiB, 네트워킹 성능 최대 10 Gbps)</li><li>storage: 16,384 GiB (≒ 16 TiB)</li><li>EBS 대역폭 4,750 Mbps</li><li>DBMS: SQL Server 2017 (14.0.3048.4)</li><li>catalog: 16개</li><li>DB data 용량: 121.8 GiB</li><li>Compatibility level: catalog 마다 상이함. (100, 110, 140)</li><li>마이그레이션 대상 오브젝트: table, stored procedure, agent job<br>※ 그 외에 view, synonym, function, assembly 등 은 없음.</li></ul><p><strong>대상 DB 선정</strong></p><ul><li>Azure SQL Managed Instance (PaaS)</li><li>고객의 요구에 따르면 PaaS DB 로의 마이그레이션을 희망하였기 때문에 다음 2가지 서비스에 대하여 고민하였고, 원본DB에서 agent job을 대상DB에서도 계속 운영해야 했기에 SQL agent 서비스가 가능한 Azure SQL Managed Instance 로 선정하였습니다.</li></ul><ol><li>Azure SQL Managed Instance <em>(SQL agent 서비스 지원)</em></li><li>Azure SQL Database <em>(SQL agent 서비스 불가)</em></li></ol><p>※ 참고: Azure SQL 서비스 별 특성</p><p><img src="/img/azure-dms-2021-04/Azure_SQL.png"></p><ul><li>tier 선택: general purpose, Gen5, 16 vCore (memory 81.6GiB)<br>※ 원본DB 16 vCPU 와 가장 근사치</li><li>storage: 416 GiB</li></ul><p><img src="/img/azure-dms-2021-04/SQL_Managed_Instance_price.png"></p><p><a href="https://azure.microsoft.com/ko-kr/pricing/details/azure-sql/sql-managed-instance/single/">Azure SQL Managed Instance 가격</a></p><h2 id="3-작업-시나리오"><a href="#3-작업-시나리오" class="headerlink" title="3. 작업 시나리오"></a>3. 작업 시나리오</h2><p><img src="/img/azure-dms-2021-04/DMS_architecture.png"></p><h3 id="사전-준비"><a href="#사전-준비" class="headerlink" title="사전 준비"></a>사전 준비</h3><h3 id="1-네트워크-연결"><a href="#1-네트워크-연결" class="headerlink" title="1. 네트워크 연결"></a>1. 네트워크 연결</h3><ul><li>Azure DMS 에서 원본DB에 접속할 수 있도록 네트워크를 구성합니다.</li><li>원본DB 내에서 백업파일(.bak)을 생성할 공유폴더를 생성하고, SQL Server 서비스의 시작계정이 해당 공유폴더에 대한 모든 권한을 갖도록 설정합니다.</li><li><code>\\public_ip\Shared_folder</code> 로 접근할 수 있도록 네트워크 어댑터 안에 IPv4 항목에 DHCP 가 아닌 현재 부여받은 internal ip, public ip 를 입력합니다.</li></ul><p>모든 제어판 항목 &gt; 네트워크 연결 &gt; 특정 ethernet adapter (우클릭) 속성 &gt; 인터넷 프로토콜 버전 4(TCP&#x2F;IPv4) 속성 &gt; 다음 IP&#x2F;DNS 주소 사용에서 IP 입력 &gt; 고급 &gt; IP 설정 탭 &gt; IP 주소 “추가” &gt; public ip 입력 후 확인 &gt; 확인 &gt; 확인</p><p><img src="/img/azure-dms-2021-04/ip_fix2.png"></p><h3 id="2-DMS와-migration-project-생성"><a href="#2-DMS와-migration-project-생성" class="headerlink" title="2. DMS와 migration project 생성"></a>2. DMS와 migration project 생성</h3><ul><li>DMS 리소스는 생성이 완료되는 데까지 시간이 오래 걸리니 미리 생성해놓으시는 것을 추천드립니다. (아주 오~래 걸립니다ㅠ)</li></ul><p>DMS 이름 입력 &gt; 계층은 프리미엄 (4vCore) 선택 &gt; vnet 선택 &gt; 태그 입력 &gt; 검토 + 만들기</p><p><img src="/img/azure-dms-2021-04/dms_creation_01.png"></p><ul><li>DMS 생성이 완료되면 DMS 하위에 DMP (<code>Database Migration Project</code>)를 생성합니다. DMP 는 짧은 시간 내에 생성이 됩니다.</li><li><strong>Migration activity type</strong> 은 online, offline, SSIS package 가 있으며 activity type에 따라 지원되는 source, target 별 DB 유형은 다음 링크에서 확인할 수 있습니다.</li></ul><p><a href="https://docs.microsoft.com/ko-kr/azure/dms/resource-scenario-status">Azure Database Migration Service에서 지원하는 마이그레이션 시나리오의 상태</a></p><ul><li>DMP를 생성한 다음, 바로 이어서 migration wizard 가 나옵니다.</li></ul><ol><li>Select source: 원본DB에 대한 접속 정보 입력</li><li>Select target: 대상DB에 대한 접속 정보 입력</li></ol><p><img src="/img/azure-dms-2021-04/task_01.png"></p><ol start="3"><li>Select databases: migration 할 catalog를 선택</li><li>Select logins: migration 할 SQL로그인을 선택</li></ol><p><img src="/img/azure-dms-2021-04/task_015.png"></p><ol start="5"><li>Configure migrations settings: 백업경로, 계정, SAS (share access signature) URI 입력<br>※ 가장 까다로운 부분입니다.</li></ol><p><img src="/img/azure-dms-2021-04/task_02.png"></p><h3 id="3-Azure-blob-storage-account"><a href="#3-Azure-blob-storage-account" class="headerlink" title="3. Azure blob storage account"></a>3. Azure blob storage account</h3><p>원본DB 의 백업파일(*.bak)을 만들어서 Azure 영역 안으로 가져올 때 사용될 storage account 를 생성하고 그 하위에 blob container를 생성합니다. <strong>Large file shares</strong> 는 <strong>Enabled</strong>로 설정합니다.</p><p><img src="/img/azure-dms-2021-04/storage_account_create.png"></p><h2 id="4-마이그레이션을-시작하자"><a href="#4-마이그레이션을-시작하자" class="headerlink" title="4. 마이그레이션을 시작하자"></a>4. 마이그레이션을 시작하자</h2><p>자, 이제 모든 힘겨운 사전 준비는 마쳤으며 산뜻한 기분으로 실제 마이그레이션 작업을 시작해보겠습니다.</p><p><strong>Azure DMS &gt; Database Migragion Project &gt; task (오프라인 마이그레이션)</strong><br><strong>새 작업</strong> 클릭 &gt; 원본DB, 대상DB에 로그인 비밀번호 다시 입력 &gt; <strong>작업 이름</strong> 입력 &gt; <strong>Start migration</strong> 클릭</p><p>아래 그림대로 작업 이름이 보여지게 되고 [상태] 값은 <code>대기,진행중,실패,완료됨</code> 등으로 표시됩니다.<br><img src="/img/azure-dms-2021-04/task_03.png"></p><p>원본DB의 네트워크 대역폭이 클수록, 백업파일의 용량이 작을수록 migration 작업 시간은 단축됩니다.</p><h2 id="5-마이그레이션-사후평가"><a href="#5-마이그레이션-사후평가" class="headerlink" title="5. 마이그레이션 사후평가"></a>5. 마이그레이션 사후평가</h2><p>아래 엑셀시트로 정리한 catalog list 대로 마이그레이션 작업을 진행했습니다.</p><p><img src="/img/azure-dms-2021-04/mig_complete_01.png"></p><h3 id="원본-대상-의-object-data-차이-비교"><a href="#원본-대상-의-object-data-차이-비교" class="headerlink" title="원본,대상 의 object, data 차이 비교"></a>원본,대상 의 object, data 차이 비교</h3><p>다음 SQL문을 원본DB, 대상DB에 각각 실행하고 한 엑셀시트에 모아서 테이블의 갯수와 각 테이블의 record count를 비교해보았습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 모든 catalog에 대한 각 테이블의 record count 출력</span><br>USE tempdb;<br>GO<br>IF OBJECT_ID(<span class="hljs-string">&#x27;tempdb.dbo.#TBL_ROW_COUNT&#x27;</span>) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>   <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> tempdb.dbo.#TBL_ROW_COUNT;<br>GO<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> #TBL_ROW_COUNT (DB_NAME NVARCHAR(<span class="hljs-number">100</span>), TBL_NAME NVARCHAR(<span class="hljs-number">100</span>), CNT <span class="hljs-type">INT</span>);<br>GO<br><span class="hljs-keyword">EXEC</span> sp_MSforeachdb N<span class="hljs-string">&#x27;USE ?</span><br><span class="hljs-string">IF DB_ID() &gt; 4 BEGIN</span><br><span class="hljs-string">SELECT &#x27;&#x27;INSERT INTO #TBL_ROW_COUNT SELECT DB_NAME = &#x27;&#x27;&#x27;&#x27;&#x27;&#x27; + DB_NAME() + &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, TABLE_NAME = N&#x27;&#x27;&#x27;&#x27;&#x27;&#x27; + CAST(B.name AS NVARCHAR(100)) + &#x27;&#x27;.&#x27;&#x27; + A.name + &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, CNT = COUNT(*) FROM [&#x27;&#x27; + DB_NAME() + &#x27;&#x27;].[&#x27;&#x27; + B.name + &#x27;&#x27;].[&#x27;&#x27; + A.NAME + &#x27;&#x27;] (nolock)&#x27;&#x27;</span><br><span class="hljs-string">FROM SYS.OBJECTS A INNER JOIN SYS.SCHEMAS B ON A.schema_id = B.schema_id</span><br><span class="hljs-string">WHERE TYPE = &#x27;&#x27;U&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">END</span><br>GO<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tempdb.dbo.#TBL_ROW_COUNT<br></code></pre></td></tr></table></figure><h3 id="추가적인-조치"><a href="#추가적인-조치" class="headerlink" title="추가적인 조치"></a>추가적인 조치</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 마이그레이션 이후에 대상DB에는 원본DB와는 다르게 쿼리저장소 기능이 자동으로 켜져있었습니다.</span><br><span class="hljs-comment">-- 동일한 환경으로 만들어주기 위해 QUERY_STORE = OFF 처리했습니다.</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;ALTER DATABASE [&#x27;</span> <span class="hljs-operator">+</span> name <span class="hljs-operator">+</span> <span class="hljs-string">&#x27;] SET QUERY_STORE = OFF;&#x27;</span><br><span class="hljs-keyword">FROM</span> sys.databases<br><span class="hljs-keyword">WHERE</span> database_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 각 데이터베이스에 적용할 옵션 스크립트 생성 - 소유자 변경</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;ALTER AUTHORIZATION ON DATABASE::[&#x27;</span> <span class="hljs-operator">+</span> name <span class="hljs-operator">+</span> <span class="hljs-string">&#x27;] TO [owner_name];&#x27;</span><br><span class="hljs-keyword">FROM</span> sys.databases<br><span class="hljs-keyword">WHERE</span> database_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h2 id="6-느낀-점"><a href="#6-느낀-점" class="headerlink" title="6. 느낀 점"></a>6. 느낀 점</h2><p>Azure 내에서 DB를 운영하기 위한 migration 도구로서 Azure DMS 는 매우 좋은 서비스라고 생각합니다. source, target에서 migration 지원 가능한 DB 유형을 숙지한 상태에서 적절한 migration 계획이 나올 수 있겠습니다. AWS DMS와 비교해보았을 때 Azure DMS는 MS SQL Server에 조금 더 최적화된 서비스라고 보여집니다. 이 글에서 표현되지는 않았지만, 공유폴더 및 계정을 설정하는 부분에서 사례에 걸맞는 인터넷 자료를 찾기 어려워서 애를 먹었었습니다.</p><p><strong>Thanks to.</strong><br>감사의 말씀 전합니다.</p><p>공유폴더 및 계정을 설정하는 부분에서 Microsoft의 SQL Server 엔지니어 분의 많은 도움을 받았습니다.<br>최근(21년 3월)에 우리 클라우드메이트에 합류해주신 <strong>cm.yang</strong> 님께서 migration 작업을 함께 해주셔서 원활히 진행되었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database Migration Service</tag>
      
      <tag>DB migration</tag>
      
      <tag>Azure DMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>스프린트, 직접 해본 이야기</title>
    <link href="/2021/04/sprint-experience/"/>
    <url>/2021/04/sprint-experience/</url>
    
    <content type="html"><![CDATA[<h2 id="2달-만에-자사-솔루션-MVP-만들기-5명이서…"><a href="#2달-만에-자사-솔루션-MVP-만들기-5명이서…" class="headerlink" title="2달 만에 자사 솔루션 MVP 만들기 (5명이서…)"></a>2달 만에 자사 솔루션 MVP 만들기 (5명이서…)</h2><p>자사 솔루션 개발이라는 프로젝트가 주어졌습니다. MVP(Minimum viable product)를 2개월 동안 개발해야 하는 상황이었습니다. 이번 프로젝트를 스프린트 방식으로 개발해보고자 하는데, 스프린트 기간은 개발해야 하는 상품과 서비스, 상황에 따라 달라질 수 있습니다. 자사 솔루션을 MVP로 개발하는데 필요한 핵심 기능 구현을 목표로 세우고 각 스프린트를 2주씩 진행하기로 했습니다.</p><blockquote><p><strong>MVP(Minimum Viable Product) 개발이란?</strong> ‘최소한의 노력으로 최대한의 고객 검증이 가능한 버전의 제품’을 개발하는 것! 검증하고자 하는 핵심 기능을 짧은 시간 안에 만든 뒤 고객 피드백에 따라 다음 회차 개발에 추가할 기능들을 결정합니다.</p></blockquote><p><img src="/img/agile-exp-2021-04/mvp.jpeg"></p><h2 id="스프린트-설정하기"><a href="#스프린트-설정하기" class="headerlink" title="스프린트 설정하기"></a>스프린트 설정하기</h2><p>자사 솔루션의 핵심 기능 별로 스프린트 목표를 4개로 쪼개고 각 기간은 최대 2주(근무일 10일)로 설정하였습니다. 그리고 각 스프린트마다 구현해야 할 결과물에 대하여 팀원들과 협의를 통하여 결정하였습니다.</p><p><img src="/img/agile-exp-2021-04/sprint.png"></p><ul><li><strong>과제</strong>: 자사 솔루션 만들기</li><li><strong>팀</strong>: 데이터 전문가, 웹앱 백&#x2F;프론트엔드 전문가, BI 전문가, 영업 담당자</li><li><strong>시간</strong>: 프로젝트 업무만 할 수 있도록 Full time을 확보하며, 하루 업무 집중 시간은 4시간으로 정했습니다.</li><li><strong>장소</strong>: 회사 회의실을 사용하고, 중간 커뮤니케이션은 Teams 메신저를 통해 온라인으로 진행하였습니다.</li><li><strong>진행자</strong>: PM을 선정하여 전체 프로젝트 일정과 커뮤니케이션, 작업 진척도를 확인하였습니다.</li></ul><h2 id="PM으로서-크루들에게-제시한-몇-가지-거버넌스-중-강조한-항목들이-있었습니다"><a href="#PM으로서-크루들에게-제시한-몇-가지-거버넌스-중-강조한-항목들이-있었습니다" class="headerlink" title="PM으로서 크루들에게 제시한 몇 가지 거버넌스 중 강조한 항목들이 있었습니다."></a>PM으로서 크루들에게 제시한 몇 가지 거버넌스 중 강조한 항목들이 있었습니다.</h2><ul><li><strong>주체적 사고</strong>: 본인이 제품을 사용할 고객이라고 생각하고 주체적인 사고를 하자.</li><li><strong>다양성</strong>: 말한 사람이 반드시 구현의 책임을 지는 것은 아니다.</li><li><strong>짧고 빈번한 논의</strong>: 논의가 다 된 사항에 대해서는 즉시 종료. 추가 사항이 있다면 1:1로 해결.</li><li><strong>실행</strong>: Plan - Do - See 중 ‘Do’가 가장 중요하다.</li><li><strong>자아 실현</strong>: 좋은 제품을 개발하는 것은 회사의 성공이기도 하지만, 본인의 성공이기도 하다.</li></ul><h2 id="진행-과정"><a href="#진행-과정" class="headerlink" title="진행 과정"></a>진행 과정</h2><p>1개의 스프린트는 5단계로 나뉘어 실행되었습니다.</p><ul><li>1단계 : 아이디어 퍼붓기</li><li>2단계 : 기술 탐색</li><li>3단계 : 방향 결정 및 구현</li><li>4단계 : 더 열심히 구현</li><li>5단계 : 테스트 및 보완</li></ul><h2 id="1단계-아이디어-쏟아내기"><a href="#1단계-아이디어-쏟아내기" class="headerlink" title="1단계. 아이디어 쏟아내기"></a>1단계. 아이디어 쏟아내기</h2><p>업무 영역별이 아닌 모든 크루가 모여 본인의 업무 영역이 아니더라도 함께 아이디어를 개진할 수 있도록 하였습니다. 이른바 ‘아이디어 쏟아내기’ 미팅은 우리가 갖고 있는 제한된 리소스는 배제한 상태에서 ‘우리가 할 수 있는’, ‘선택할 수 있는’ 모든 아이디어에 대해서 다양하게 발언하며 진행했습니다. 여러 아이디어들은 대략 아래와 같은 형태였습니다.</p><blockquote><p><em>“개발 스택은 이러한 이유로 이렇게 선정해야 합니다.” “디자인 테마는 유료 템플릿을 구매하여 최적화 하면 작업 시간을 줄일 수 있습니다.” “개발DB, 운영DB 에 대한 운영은 이렇게 하는 것이 좋습니다.”</em></p></blockquote><h2 id="2단계-기술-탐색"><a href="#2단계-기술-탐색" class="headerlink" title="2단계. 기술 탐색"></a>2단계. 기술 탐색</h2><p>1단계에서 나온 여러가지 아이디어들을 구현해내기 위한 기술 탐색을 진행했습니다. 러닝커브가 얼마나 발생할지, 보안 상 문제가 없는지 등에 대한 점수를 부여하기 보다 오로지 기술 스택을 찾아내는데에만 집중 했습니다.</p><h2 id="3단계-방향-결정-및-구현"><a href="#3단계-방향-결정-및-구현" class="headerlink" title="3단계. 방향 결정 및 구현"></a>3단계. 방향 결정 및 구현</h2><p>3단계에서는 2단계에서 탐색된 다양한 기술들을 한데 모아, 여러가지 측면으로 지표를 설정하여 각 기술을 모든 크루가 평가하였고 획득한 점수가 가장 높은 것을 채택하여 방향을 결정하였습니다. 시간이 여유롭지 않다고 판단되어, 결정된 방향에 맞춰서 바로 구현을 진행했습니다.</p><h2 id="4단계-더-열심히-구현"><a href="#4단계-더-열심히-구현" class="headerlink" title="4단계. 더 열심히 구현"></a>4단계. 더 열심히 구현</h2><p>4단계에서는 결정된 방향과 구현된 형태를 더욱 집중에서 구현해나갔던 단계였습니다. 아래는 PM 포함 5명의 크루가 각자 구현을 담당했던 job 입니다.</p><ul><li>A크루: 외부 API 또는 SDK 와 연동하여 우리에게 필요한 데이터를 load하여 DB에 적재.</li><li>B크루: DB 내에서 서비스 가능한 형태로 transform. <em>(in fact, me)</em></li><li>C크루: WebApp 전반적인 front-end, back-end 개발</li><li>D크루: WebApp의 admin 기능 개발 (BackOffice)</li><li>E크루: WebApp front-end 에서 데이터 시각화 개발</li></ul><p>서비스 데이터의 흐름을 정의하였고, 대략 이렇게 유통 됩니다.</p><p>B : DB 설계&#x2F;구축 → A : 외부 데이터 DB 적재 → C : 웹앱에 로그인하여 페이지 호출 → E : 데이터 시각화 표현</p><h2 id="5단계-테스트-및-보완"><a href="#5단계-테스트-및-보완" class="headerlink" title="5단계. 테스트 및 보완"></a>5단계. 테스트 및 보완</h2><p>Sprint 의 말미에 5단계 ‘테스트 및 보완’ 에서는 구현된 기능에 대해 모두 모여서 (또는 온라인 미팅) 잘 된 점에 대해서 리뷰하고 기능적으로 미진한 부분에 대한 피드백을 전달했습니다. 또한 반복적인 QA 활동을 통하여 디버깅, 기능 향상, UI&#x2F;UX 향상을 도모했습니다.특정 크루에게만 연관성이 높은 이슈인 경우에는 모두 모인 자리가 아닌 별도의 1:1 미팅을 통하여 피드백을 드렸습니다.</p><h2 id="스프린트-작업-진척도-관리-Azure-DevOps-Boards"><a href="#스프린트-작업-진척도-관리-Azure-DevOps-Boards" class="headerlink" title="스프린트 작업 진척도 관리 - Azure DevOps Boards"></a>스프린트 작업 진척도 관리 - Azure DevOps Boards</h2><p>Azure DevOps Boards에서는 Azure DevOps에서 등록한 모든 work item을 관리할 수 있습니다. 특히, Boards 기능 중 제가 가장 좋아하는 기능은 “Sprints” 인데요, 각 각의 작업(work item)에 목표 수행시기(time)를 덧입히는 기능이라고 이해하시면 됩니다. Boards 안에는 Sprints 외에도 좋은 기능들이 많이 있는데요. Boards 에서 칸반보드 형태로 각 스윔레인 마다 feature, story의 상태를 한 눈에 파악할 수 있으며, Backlog에서는 모든 work item에 대한 tree 구조의 백로그 뷰가 제공됩니다.</p><p>각 Sprint 마다 기간은 2주로 설정되어 있고, 비대면 미팅을 개최하여 2주 이내에 완수할 수 있는 task 들을 먼저 각자 sketch-up 할 수 있게 했습니다. 그리고 정해진 개발 일정을 준수할 수 있도록 1~2일 마다 크루의 작업 진행 상황을 체크하였습니다. 아무래도 짧은 기간 내에 MVP를 만들어내기 위해서는 작업 진척도 관리가 필수적이었습니다. 작업이 잘되고 있는지, 잘 안되고 있다면 어떤 부분 때문에 그런지 각 크루들과 온라인 및 오프라인으로 수시로 커뮤니케이션을 하면서 리뷰 및 QA 를 진행하였습니다. 진행 중 예상하지 못한 변수가 발생했을 때에는 함께 해결책을 찾아드리거나, Plan B를 제시하였습니다.</p><p><img src="/img/agile-exp-2021-04/azureboards.png"></p><h2 id="결과-및-후기"><a href="#결과-및-후기" class="headerlink" title="결과 및 후기"></a>결과 및 후기</h2><p>약속된 2달이 지난 시점에 우리는 당초 계획했던 MVP를 높은 달성 수준을 보이며 출시할 수 있었습니다. TF 크루들이 굉장한 실력자였던 것은 PM으로서 크나큰 행운이었다고 생각합니다. 모든 크루들은 본인이 해야 할 일을 정확히 이해하고 있었고, 모든 task들이 계획했던 스프린트 기간 내에 모두 완료되었습니다.</p><p>개인적으로 어려웠던 점을 꼽아본다면, 어떤 어려움에 봉착한 크루가 있는지 지속적으로 살피고 업무 진척이 되지 않는 크루에게 다가가 어떤 어려움인지 들어본 후 적절한 솔루션을 찾아서 알려주는 것이었습니다. 각 크루마다의 업무 진척 상황을 살피고 다가갈 때에 너무 재촉하는 느낌으로 다가가지 않으려고 노력했습니다.</p><p>팀 내 협업 능력이 프로젝트를 성공적으로 마무리하는데 정말 큰 몫을 한다는 것을 다시 한 번 깨달았던 좋은 경험이었습니다.</p>]]></content>
    
    
    <categories>
      
      <category>Story</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Google Sprint</tag>
      
      <tag>Minimum Viable Product</tag>
      
      <tag>Agile 개발방법론</tag>
      
      <tag>MVP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS DMS를 활용하여 Oracle에서 MySQL로 DB 마이그레이션 하기</title>
    <link href="/2020/11/aws-dms-from-ora-to-mysql/"/>
    <url>/2020/11/aws-dms-from-ora-to-mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="시작하기-전에"><a href="#시작하기-전에" class="headerlink" title="시작하기 전에"></a>시작하기 전에</h2><p>현대차, 카카오, KT, 대한항공 등 에서 촉발된 탈(脫) Oracle 프로젝트(escape from oracle)는 오픈소스 DB, 클라우드 DB 의 안정성이 높아지면서 국내 뿐만 아니라 해외에서 먼저 트렌드로 자리 잡았으나, 그럼에도 불구하고 현존 RDBMS 중 성능 최강인 (가격도 최강) Oracle 을 100% 대체할 수 있는 RDBMS는 안타깝게도 아직까지는 없다고 생각합니다.</p><p>(2020년말기준) 그렇기 때문에 Oracle에서 벗어나려면 Oracle에서만 지원하는 기능을 어떻게 타겟DB에서 대체 또는 구현할지 에 대한 깊은 고민이 필요합니다.</p><p>이번 C고객사에서는 시범적으로 기존 온프레미스 Oracle 의 레플리카를 퍼블릭 클라우드 환경으로 마이그레이션 하여 향후에 있을 감사 등 에 대응할 수 있길 원하셨습니다. 미션 크리티컬한 서비스 DB 가 아니여서 다운타임에 대한 고려가 불필요했습니다. 빗발치는 OLTP 가 발생하지 않는 DB의 마이그레이션이라… 꿀냄새가 진동하네요.</p><p><img src="/img/aws-dms-2020-11/toon.png"><br><code>Close your eyes and hope for the best.</code> AWS에서 제공하는 DB 이관 도구는 꽤나 강력합니다.</p><h2 id="사전-검토"><a href="#사전-검토" class="headerlink" title="사전 검토"></a>사전 검토</h2><ul><li><p>소스 DB 체크  </p><ul><li>버전: Oracle 11g Enterprise (Release 11.2.0.4.0) on TNS for Linux - 64bit</li><li>총용량(1TiB 가량)</li><li>오브젝트 현황 파악</li></ul></li><li><p>타겟 DB 체크  </p><ul><li>버전: MySQL 8.0.21 on Amazon Linux 2 - 64bit</li><li>EC2 인스턴스 유형: r5.4xlarge (vCPUs: 16, 메모리: 128GiB)</li></ul></li><li><p>AWS 콘솔에서 작업자 접속용 EC2 인스턴스 생성 (이하 작업콘솔)</p></li><li><p>작업콘솔 에서 소스, 타겟 접속 가능하도록 가상 네트워크 구성 및 방화벽 설정</p></li><li><p>작업 절차 거버넌스</p><ul><li>Schema Conversion Tool (이하 SCT) 로 스키마 이관</li><li>Database Migration Service (이하 DMS) 로 데이터 이관</li><li>미싱 스키마, 미싱 데이터 수동 점검</li></ul></li><li><p>Procedure, fucntion, sequence 는 마이그레이션 대상에서 제외</p></li><li><p>별도의 SSL 구성은 하지 않음</p></li></ul><h2 id="마이그레이션-아키텍쳐"><a href="#마이그레이션-아키텍쳐" class="headerlink" title="마이그레이션 아키텍쳐"></a>마이그레이션 아키텍쳐</h2><p><img src="/img/aws-dms-2020-11/architecture.png"></p><ol><li>작업콘솔의 SCT에서 소스의 스키마를 DDL 형태로 로드하여 타겟에 적용합니다.</li><li>AWS 콘솔에서 DMS 내에 필요한 리소스를 셋팅 합니다. (복제 인스턴스, 소스&#x2F;타겟 엔드포인트 생성)</li><li>DMS 내에 여러 마이그레이션 태스크를 소스 스키마 단위로 생성하고 일괄 실행합니다.</li><li>소스, 타겟에 직접 SQL을 실행하여 전체 오브젝트 현황을 비교하고 검증합니다.</li></ol><h2 id="1-작업-콘솔-셋팅"><a href="#1-작업-콘솔-셋팅" class="headerlink" title="1. 작업 콘솔 셋팅"></a>1. 작업 콘솔 셋팅</h2><p>자, 이제 사전 검토했고 아키텍쳐 파악했으니, 실제로 시작해봅시다.</p><ol><li>AWS 콘솔에서 퍼블릭 IPv4 와 RDP port 를 확인하여 작업콘솔에 원격 접속 합니다.</li></ol><p><img src="/img/aws-dms-2020-11/aws_01.png"></p><ol start="2"><li>작업콘솔에서 소스 검증을 위하여 SQL Developer 설치 후 소스DB 접속 테스트를 합니다.</li></ol><p><img src="/img/aws-dms-2020-11/sqldeveloper.png"></p><ol start="3"><li>작업콘솔에서 타겟 검증을 위하여 WorkBench 설치 후 타겟DB 접속 테스트를 합니다.</li></ol><p><img src="/img/aws-dms-2020-11/workbench.png"></p><ol start="4"><li>작업콘솔에서 스키마 이관을 위하여 SCT 설치 후 소스, 타겟 접속 테스트를 합니다. SCT &gt; New Project wizard IU 입니다. Source engine 의 기본값이 Oracle인 것이 흥미롭습니다.</li></ol><p><img src="/img/aws-dms-2020-11/sct_01.png"></p><h2 id="2-타겟-DB-셋팅"><a href="#2-타겟-DB-셋팅" class="headerlink" title="2. 타겟 DB 셋팅"></a>2. 타겟 DB 셋팅</h2><h3 id="2-1-Buffer-pool"><a href="#2-1-Buffer-pool" class="headerlink" title="2.1. Buffer pool"></a>2.1. Buffer pool</h3><p>DMS가 타겟DB에 값을 쓸 때 버퍼캐쉬 크기가 처리 성능을 크게 좌우합니다. 디폴트값(128MB)에서 일시적으로 서버 메모리 한도 내에서 최대한으로 설정하도록 권장 드립니다. 금번 프로젝트의 경우 64GiB 로 설정하여 진행했습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- buffer pool size 확인 (GiB)</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@innodb_buffer_pool_size</span> <span class="hljs-operator">/</span> <span class="hljs-number">1024</span> <span class="hljs-operator">/</span> <span class="hljs-number">1024</span> <span class="hljs-operator">/</span> <span class="hljs-number">1024</span>;<br></code></pre></td></tr></table></figure><p>※ Innodb buffer pool size가 쓰기 성능에 얼만큼 영향이 큰지 테스트한 블로그 링크 참고 바랍니다.<br>출처: <a href="https://santander.co.kr/151">innodb mysql&#x2F;mariadb insert 속도 높이기</a></p><h3 id="2-2-Timezone"><a href="#2-2-Timezone" class="headerlink" title="2.2. Timezone"></a>2.2. Timezone</h3><p>타겟 EC2 에 MySQL 바이너리 설치한 초기 상태에서는 timezone 을 소스와 동일한 timezone 으로 설정해주어야 합니다. 먼저 소스 DB의 timezone을 확인합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>   DBTIMEZONE,<br>   SESSIONTIMEZONE<br><span class="hljs-keyword">FROM</span>  DUAL;<br></code></pre></td></tr></table></figure><table><thead><tr><th>DBTIMEZONE</th><th>SESSIONTIMEZONE</th></tr></thead><tbody><tr><td>+09:00</td><td>UTC</td></tr></tbody></table><p>소스DB의 timezone 은 UTC + 09:00 인 Korea Standard Time(KST) 인 것을 확인 했습니다. 타겟DB에 Asia&#x2F;Seoul timezone이 존재하는지 아래 SQL문을 실행해봅니다.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 타겟DB timezone 중에 &#x27;Seoul&#x27;이 존재하는지 확인</span><br><span class="hljs-keyword">SELECT</span>  B.NAME,A.TIME_ZONE_ID<br><span class="hljs-keyword">FROM</span>    MYSQL.TIME_ZONE A<br>        <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> MYSQL.TIME_ZONE_NAME B <span class="hljs-keyword">ON</span> A.TIME_ZONE_ID = B.TIME_ZONE_ID<br><span class="hljs-keyword">WHERE</span>   B.NAME <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Seoul&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>Asia/Seoul</code> timezone이 존재하지 않는다면 타겟 EC2 에 다음과 같은 명령을 실행합니다.<br><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-tzinfo-to-sql.html">MySQL 8.0 참조 매뉴얼 &#x2F; … &#x2F; mysql_tzinfo_to_sql — 시간대 테이블로드</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root -p mysql<br></code></pre></td></tr></table></figure><p>타겟DB 설치경로 안에 <code>/etc/my.cnf</code> 또는 <code>/etc/my.cnf.d/</code> 경로 안에 my.cnf 파일 또는 my.ini 파일을 열어 안에 다음 내용을 추가해줍니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cnf">[mysqld]<br>default-time-zone=Asia/Seoul<br></code></pre></td></tr></table></figure><p>소스DB의 timezone에 맞춰 타겟DB 의 timezone 을 Asia&#x2F;Seoul(KST) 로 변경해주어야 합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> time_zone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Asia/Seoul&#x27;</span>;<br><br><span class="hljs-comment">-- 변경된 timezone 확인</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@TIME_ZONE</span>, @<span class="hljs-variable">@system_time_zone</span>, @<span class="hljs-variable">@GLOBAL</span>.TIME_ZONE, @<span class="hljs-variable">@SESSION</span>.TIME_ZONE;<br></code></pre></td></tr></table></figure><table><thead><tr><th>@@TIME_ZONE</th><th>@@system_time_zone</th><th>@@GLOBAL.TIME_ZONE</th><th>@@SESSION.TIME_ZONE</th></tr></thead><tbody><tr><td>+09:00</td><td>KST</td><td>+09:00</td><td>+09:00</td></tr></tbody></table><p>정상적으로 적용되어 있는 것 확인 완료요!<br>※ MySQL on RDS 는 AWS 콘솔에서 Parameter Group 생성 및 적용하여 비교적 간단하게 변경 가능합니다.</p><h3 id="2-3-Charset"><a href="#2-3-Charset" class="headerlink" title="2.3. Charset"></a>2.3. Charset</h3><p>소스DB의 charset을 확인하여 타겟DB에 적용해주도록 합니다. 데이터를 이관하기 전에 신중히 결정해야할 사항이며 이관 완료 이후에 charset, collation 변경 작업은 지옥문을 여는 경험이 될 수 있습니다. 일단 먼저 소스 DB의 charset을 확인합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  NAME, <span class="hljs-keyword">VALUE</span>$<br><span class="hljs-keyword">FROM</span>    SYS.PROPS$<br><span class="hljs-keyword">WHERE</span>   NAME <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;NLS_LANGUAGE&#x27;</span><br>    ,<span class="hljs-string">&#x27;NLS_DATE_LANGUAGE&#x27;</span><br>    ,<span class="hljs-string">&#x27;NLS_CHARACTERSET&#x27;</span><br>    ,<span class="hljs-string">&#x27;NLS_NCHAR_CHARACTERSET&#x27;</span>);<br><br><span class="hljs-keyword">SELECT</span>  <span class="hljs-keyword">PARAMETER</span>, <span class="hljs-keyword">VALUE</span><br><span class="hljs-keyword">FROM</span>    NLS_DATABASE_PARAMETERS<br><span class="hljs-keyword">WHERE</span>   <span class="hljs-keyword">PARAMETER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;NLS_CHARACTERSET&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>result[0]</p></blockquote><table><thead><tr><th>NAME</th><th>VALUE$</th></tr></thead><tbody><tr><td>NLS_NCHAR_CHARACTERSET</td><td>AL16UTF16</td></tr><tr><td>NLS_LANGUAGE</td><td>AMERICAN</td></tr><tr><td>NLS_DATE_LANGUAGE</td><td>AMERICAN</td></tr><tr><td>NLS_CHARACTERSET</td><td><code>KO16KSC5601</code></td></tr></tbody></table><blockquote><p>result[1]</p></blockquote><table><thead><tr><th>PARAMETER</th><th>VALUE</th></tr></thead><tbody><tr><td>NLS_CHARACTERSET</td><td><code>KO16KSC5601</code></td></tr></tbody></table><p>NLS_CHARACTERSET 이 <code>KO16KSC5601</code>에 대응되는 charset 은 EUCKR, 또는 커버리지가 더 넓은 UTF8을 생각해볼 수 있습니다. charset EUCKR 에 대한 collation 은 EUCKR_KOREAN_CI, EUCKR_BIN 이 있는데 대소문자가 구별되는 이유로 EUCKR_BIN 이 적합합니다.</p><ul><li><code>EUCKR_BIN</code>: 한국어, 바이너리, 대소문자 구분함</li><li><code>EUCKR_KOREAN_CI</code>: 한국어, 대소문자 구분 안함</li></ul><p>Charset EUCKR, collation EUCKR_BIN을 결정했으니 이제 서버에 아래 명령을 실행해줍니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vi /etc/mysql/my.cnf<br></code></pre></td></tr></table></figure><p>파일 내용의 마지막에 다음 부분을 덧붙여준 후 :wq 로 저장 후 닫아줍니다. 그리고 서비스를 재시작하면 적용됩니다.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[client]</span><br><span class="hljs-attr">default-character-set</span>=euckr<br><br><span class="hljs-section">[mysql]</span><br><span class="hljs-attr">default-character-set</span>=euckr<br><br><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">collation-server</span> = euckr_bin<br><span class="hljs-attr">init-connect</span>=<span class="hljs-string">&#x27;SET NAMES euckr&#x27;</span><br><span class="hljs-attr">character-set-server</span> = euckr<br></code></pre></td></tr></table></figure><p>Charset, collation 도 설정 완료했습니다. 😅</p><h2 id="3-SCT로-스키마-이관"><a href="#3-SCT로-스키마-이관" class="headerlink" title="3. SCT로 스키마 이관"></a>3. SCT로 스키마 이관</h2><p><img src="/img/aws-dms-2020-11/flow_sct.png"></p><p>소스에서 SCT로 이관할 스키마를 선택하고 Next를 클릭합니다. 선택한 스키마 내에 전체 오브젝트 개수에 비례하여 시간이 오래 걸릴 수 있습니다.</p><p><img src="/img/aws-dms-2020-11/sct_02.png"></p><p>소스 스키마에 대한 로드 작업이 끝나면 여러가지 타겟의 종류 별로 몇개가 이관 가능한지, 몇개는 수동 조치를 취해야 하는지 전체 조사한 Database migration assessment report를 보여줍니다. pdf로도 다운로드 가능하며, 전체적으로 한번 훑어보고 Next를 클릭합니다.<br><em>(Procedure, funcion, sequence 는 migrating 대상이 아니므로 부담없이 Next클릭)</em></p><p><img src="/img/aws-dms-2020-11/sct_03.png"></p><p>SCT 관점에서 타겟의 엔진이 MySQL 인 것이 의미가 있고, RDS 또는 EC2 중 어떤 것인지는 중요하지 않기 때문에 Amazon RDS for MySQL을 선택하고 타겟의 접속정보 입력 후 Test connection, 접속 성공하면 Next를 클릭합니다.</p><p><img src="/img/aws-dms-2020-11/sct_04.png"></p><p>소스(좌측)에서 DDL을 추출할 스키마와 개체유형을 선택하고 Convert schema를 클릭합니다. 타겟(우측)에서 선택 체크된 항목들에 대해서 DDL을 적용하려면 Apply to database를 클릭하면 타겟 DB에 실제로 DDL이 적용됩니다.</p><p><img src="/img/aws-dms-2020-11/sct_05.png"></p><p>타겟 DB에 아래 SQL을 실행해서 정상적으로 스키마가 적용되어 있는지 확인합니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>    A.TABLE_SCHEMA, A.TABLE_NAME, A.TABLE_COLLATION, A.TABLE_COMMENT,<br>     I.INDEX_COUNT, T.TRIGGER_COUNT<br><span class="hljs-keyword">FROM</span>    INFORMATION_SCHEMA.TABLES A<br>     <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">LATERAL</span> ( <span class="hljs-comment">-- like OUTER APPLY</span><br>     <span class="hljs-keyword">SELECT</span>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> I.INDEX_NAME) <span class="hljs-keyword">AS</span> INDEX_COUNT<br>     <span class="hljs-keyword">FROM</span>    INFORMATION_SCHEMA.STATISTICS I<br>     <span class="hljs-keyword">WHERE</span>    I.TABLE_SCHEMA <span class="hljs-operator">=</span> A.TABLE_SCHEMA<br>     <span class="hljs-keyword">AND</span>    I.TABLE_NAME <span class="hljs-operator">=</span> A.TABLE_NAME<br>     LIMIT <span class="hljs-number">1</span><br>     ) I <span class="hljs-keyword">ON</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>     <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">LATERAL</span> (<br>     <span class="hljs-keyword">SELECT</span>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> TRIGGER_COUNT<br>     <span class="hljs-keyword">FROM</span>    INFORMATION_SCHEMA.TRIGGERS T<br>     <span class="hljs-keyword">WHERE</span>    T.TRIGGER_SCHEMA <span class="hljs-operator">=</span> A.TABLE_SCHEMA<br>     <span class="hljs-keyword">AND</span>    T.EVENT_OBJECT_TABLE <span class="hljs-operator">=</span> A.TABLE_NAME<br>     LIMIT <span class="hljs-number">1</span><br>     ) T <span class="hljs-keyword">ON</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">WHERE</span>    A.TABLE_SCHEMA <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/aws-dms-2020-11/wb_resultset.png"></p><p>※ 타겟DB가 MySQL 인 경우 테이블과 컬럼의 comment가 SCT로 이관되지 않음을 확인했습니다. 금번 프로젝트 진행하면서 AWS 케이스 오픈을 통하여 정식 요청하였으며, 추후 픽스될 것으로 보입니다.</p><p>SCT에 대한 상세한 가이드는 <a href="https://docs.aws.amazon.com/ko_kr/SchemaConversionTool/latest/userguide/CHAP_Welcome.html">AWS Schema Conversion Tool User Guide</a> 를 참고 바랍니다.</p><p>만약 SCT로 trigger 까지 이관시켰다면 DMS 태스크 실행 시 trigger로 인해 오류가 떨어지고 태스크가 멈출 수 있으므로 trigger 를 백업받아놓고 모두 제거하는 것을 추천드립니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 트리거 리스트 출력</span><br><span class="hljs-keyword">SHOW</span> TRIGGERS;<br><br><span class="hljs-comment">-- SCT 가 이관해준 트리거 소스는 메모장에 백업해놓고 모두 제거</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>SCHEMA_NAME<span class="hljs-operator">&gt;</span>.<span class="hljs-operator">&lt;</span>TABLE_NAME<span class="hljs-operator">&gt;</span>.<span class="hljs-operator">&lt;</span>TRIGGER_NAME<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>다시 한번 강조하지만 DMS로 데이터를 들이부은 이후에는 charset, collation 을 변경하는 데에 굉장히 긴 시간이 소요될 수 있습니다. 그래서 SCT 작업 끝나고 DMS 작업을 시작하기 이전에 아래 쿼리를 다시 실행해주면 세상 시원하겠습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> DATABASE <span class="hljs-operator">&lt;</span>database_name<span class="hljs-operator">&gt;</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> EUCKR <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> EUCKR_BIN;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>table_name<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CONVERT</span> <span class="hljs-keyword">TO</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> EUCKR <span class="hljs-keyword">COLLATE</span> EUCKR_BIN;<br></code></pre></td></tr></table></figure><p><img src="/img/aws-dms-2020-11/doubleaction.png"></p><h2 id="4-DMS로-데이터-이관"><a href="#4-DMS로-데이터-이관" class="headerlink" title="4. DMS로 데이터 이관"></a>4. DMS로 데이터 이관</h2><p><img src="/img/aws-dms-2020-11/flow_dms.png"></p><p>이제 본격적으로 DMS로 데이터를 넘겨볼껀데요. 그전에 복제 인스턴스, 엔드포인트, 마이그레이션 태스크를 생성해야 합니다.</p><p>먼저, 복제 인스턴스는 아래 사양으로 생성했습니다.</p><ul><li>클래스: dms.c4.4xlarge<br><del>(처음에는 c4.large였다가 너무 느려 속 터져서 업그레이드)</del></li><li>vCPUs: 8</li><li>메모리: 30GiB</li><li>전용EBS 대역폭: 2,000Mbps</li><li>할당 스토리지: 1000GiB</li></ul><p><img src="/img/aws-dms-2020-11/dms_01.png"></p><p>엔드포인트는 유형에 따라 소스 1개, 대상 2개로 생성했습니다. 소스DB, 타겟DB 의 접속정보를 각각 알맞게 넣어주고 테스트 실행을 해봅니다.</p><p><img src="/img/aws-dms-2020-11/dms_02.png"></p><p>마이그레이션 태스크는 아래 캡처대로 순서대로 값을 입력합니다.</p><ul><li>태스크 식별자: 식별할 수 있는 이름</li><li>복제 인스턴스: 복제 인스턴스 선택</li><li>소스 엔드포인트: 소스DB 엔드포인트 선택</li><li>대상 엔드포인트: 타겟DB 엔드포인트 선택</li><li>마이그레이션 유형: <code>기존 데이터 마이그레이션</code> 선택<br>(기존 데이터를 일회성으로 마이그레이션할 것이기 때문에)</li><li>태스크 설정 편집모드: <code>마법사</code></li><li>대상 테이블 준비 모드: 아무 작업 안 함<br>※ <code>대상에서 테이블 삭제</code> 는 DDL(drop &amp; create)을 실행하기 때문에 charset, collation, trigger 등이 원래대로 생성될 수 있음</li><li>복제에 LOB 열 포함: <code>전제 LOB 모드</code></li><li>LOB 청크 크기: 64</li><li>검증 활성화: Y</li><li>CloudWatch 로그 활성화: Y<br>※ 그외 CloudWatch 관련 설정들은 모두 <code>기본값</code></li><li>테이블 매핑 편집모드: <code>마법사</code></li><li>선택 규칙 &gt; <code>새 선택 규칙 추가</code> &gt; 스키마 입력 &gt; 테이블 이름 (필요에 따라 입력, % 는 전체 테이블)</li><li>마이그레이션 전 평가: N</li><li>마이그레이션 태스크 시작 구성: <code>나중에 수동으로</code></li><li>태그: (필요한 경우에 입력, 많이 입력할수록 추후에 찾기 용이함)</li><li><code>태스크 생성</code> 클릭</li></ul><p><img src="/img/aws-dms-2020-11/dms_03.png"></p><p><img src="/img/aws-dms-2020-11/dms_04.png"></p><p><img src="/img/aws-dms-2020-11/dms_05.png"></p><p>마이그레이션 해야할 스키마 갯수, 테이블 갯수에 따라 상황이 다르겠지만, 금번 프로젝트에서는 스키마 이름 단위로 태스크를 생성하여 마이그레이션을 진행했습니다. (테이블 이름은 % 로 그냥 둔채로)</p><p>스키마 갯수 대로 태스크를 생성해놓은 다음 태스크들을 일괄로 <code>시작</code>을 눌러줍니다.</p><p><img src="/img/aws-dms-2020-11/dms_06.png"></p><p>상태 값은 준비중, 로드중, 로드완료 등의 값들이 올 수 있으며, 아무 오류 없이 완료 되면 <code>로드 완료</code>로 바뀌게 됩니다. 이제 우리가 해야할 것은 오로지, <code>Close your eyes and hope for the best</code> 말고는 없습니다.</p><h2 id="5-마이그레이션-검증"><a href="#5-마이그레이션-검증" class="headerlink" title="5. 마이그레이션 검증"></a>5. 마이그레이션 검증</h2><p>데이터까지 마이그레이션이 완료된 후에는 소스, 타겟의 difference 가 존재하는지 검증해봐야 하며 검증 절차는 아래와 같이 구성하였습니다.</p><ol><li>소스, 타겟의 테이블(뷰 포함) 갯수 비교</li><li>소스, 타겟의 테이블 당 row count 비교</li><li>소스, 타겟의 Index 갯수 비교</li><li>소스, 타겟의 Constraint 갯수 비교</li></ol><p>위 절차들의 검증이 모두 끝나고 나면 비로소 DB 마이그레이션 작업이 완료됐다고 볼 수 있습니다. 아래 이미지는 Google sheet로 기록해놓았던 이관진행 문서입니다.</p><p><img src="/img/aws-dms-2020-11/validation.png"></p><h2 id="작업을-마치며"><a href="#작업을-마치며" class="headerlink" title="작업을 마치며"></a>작업을 마치며</h2><p>그동안 Youtube로만 접했던 AWS의 DMS, SCT를 직접 사용해보니 아주 약간의 버그성 동작과 모호한 UI 로 인해 작업 초반에는 생산성이 떨어졌던 것이 사실이나, 소스&#x2F;타겟에서 지원하는 DB engine 종류가 매우 다양하며 특히 데이터를 일괄로 퍼서 넘기는 속도 등 성능이 뛰어나다고 봅니다.</p><p><del>(육아와 DB이관은 캐시템으로 해결하세요.)</del></p><p>향후에 실 서비스 상태의 DB를 마이그레이션 하게 되는 경우 추가로 고려해야 할 것들을 대략 정리해봤습니다.</p><ol><li>다운타임 최소화</li><li>지속적인 변경 사항 복제 시 지연시간 최소화</li><li>실패 시 roll-back 방안</li></ol><p>전통적인 DB 마이그레이션 작업은 일부 DBA, 일부 DB개발자 들만의 야간 작업으로 많이 치부되어오곤 했었습니다. 마이그레이션 진행 시 철야는 물론이었고, 스크립트 수작업하는 경우도 부지기수 였고, 경험 많은 DBA가 없으면 심각한 예외상황에 직면했을 경우 롤백하는 경우도 많았었지요.</p><p>AWS DMS의 경우 AWS콘솔에서 누구나 쉽게 이해하고 사용할 수 있도록 구성되어 있어서, 이제 앞으로의 DB 마이그레이션은 기성 DBA 들만의 작업이 아닐 수 있겠다는 생각이 들었네요.</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS DMS</tag>
      
      <tag>DB migration</tag>
      
      <tag>Database Migrtation Service</tag>
      
      <tag>SCT</tag>
      
      <tag>Schema Conversion Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>부동 소수점은 표현상 효율적이지만, 정확하진 않다.</title>
    <link href="/2017/01/floating-point/"/>
    <url>/2017/01/floating-point/</url>
    
    <content type="html"><![CDATA[<h2 id="부동-소수점"><a href="#부동-소수점" class="headerlink" title="부동 소수점"></a>부동 소수점</h2><p>부동 소수점에 대해 잘 정리된 포스팅이 있다.<br>부동 소수점 (SQL server 에서는 float, real) 은 표현상 효율적이긴 하나, 정확하진 않다.<br>SQL server 에서는 decimal, numeric, money, smallmoney 가 정확함.</p><p>본 포스트에 기재된 모든 내용은 아래 출처에서 복사해온 내용이며 스터디 목적으로 다시금 곱씹어보았다.</p><p>출처: <a href="http://thrillfighter.tistory.com/349">http://thrillfighter.tistory.com/349</a></p><h2 id="부동-소수점에-대한-이해"><a href="#부동-소수점에-대한-이해" class="headerlink" title="부동 소수점에 대한 이해"></a>부동 소수점에 대한 이해</h2><p>부동 소수점 표현은 아주 큰 수와 아주 작은 수를 효율적으로 표현하기 위해서 사용한다. 여기서 효율적이란 표현은 정확하다는 표현은 아니고 효율적일 수록 오차가 발생하기 마련이다. 우선 부동소수점 표현을 어떤 방식으로 하는지 이해하고, 오차가 발생할 수 밖에 없는 원리도 이해해보자.</p><p>우선 우리가 10진수를 10으로 나누거나 곱하면 소수점의 위치를 변경할 수 있다. 이와 마찬가지로 2진수 또한 2로 나누거나 곱하면 소수점 위치가 한 칸씩 이동된다. (자세한 설명은 하지 않겠지만, 이 원리를 이용해 진수변환도 한다는 것을 알아 두자.) 부동 소수점은 이런 원리를 이용해서 소수점의 위치를 나타낸다.</p><p>예를 들어 1001.1011 이란 수가 있다면, 부동 소수점은 이 수를 1.0011011 * 2^ 으로 표현 한다.<br>여기서 3은 위에서 설명한 원리를 통해 소수점의 위치를 정하게 되고 앞에 1.0011011은 1001.1011을 정규화한 것이다.</p><h2 id="정규화-방법"><a href="#정규화-방법" class="headerlink" title="정규화 방법"></a>정규화 방법</h2><p><img src="/img/floating-point-2017-01/01.png"></p><h2 id="지수부"><a href="#지수부" class="headerlink" title="지수부"></a>지수부</h2><p><img src="/img/floating-point-2017-01/02.png"></p><h2 id="바이어스-상수"><a href="#바이어스-상수" class="headerlink" title="바이어스 상수"></a>바이어스 상수</h2><p><img src="/img/floating-point-2017-01/03.png"></p><p><img src="/img/floating-point-2017-01/04.png"></p><h2 id="부동-소수점의-오차"><a href="#부동-소수점의-오차" class="headerlink" title="부동 소수점의 오차"></a>부동 소수점의 오차</h2><p>부동 소수점은 적은 비트로 큰 수를 표현할 수 있지만, 이런 효율성은 정확성을 떨어뜨릴 수 밖에 없다. float의 가수부의 크기는 23bit인데, 23은 실제로 값자리수(길이)를 나타낸다. 부동 소수점의 표현 방식상 정수값 자리수가 23을 넘어가게 되면 소수점 이동이 23(가수의 길이)이 넘어가므로 가수부의 길이를 초과하여 소수점 이하를 표현할 길이 없어진다. 길이를 넘어가게 되면 가수의 마지막 자리 값은 넘어간 수만큼의 0이 생긴다.</p><p>지수값이 24인 경우 0이 하나 생겼다. 2진수의 LSD(least significant Digit)가 무조건 0이기 때문에 홀수를 표현할 수 없다.</p><p>지수값이 25가 되면 0이 두개 생긴다. 따라서 4의 배수만 표현된다. 이런 식으로 오차가 점점 늘어나는데, 사실 이런 오차는 지수값이 23이넘어가면 값의 크기에 비해서 아주 작은 값이 되므로 그렇게 큰 차이는 아니지만, 정밀도가 떨어질 수밖에 없다. 따라서 double 타입의 자료형을 사용하면 이런 오차를 좀 더 줄일 수 있다.</p><hr><p>아래는 부동 소수점에 대한 위키백과 내용 입니다.  </p><p><a href="https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90">https://ko.wikipedia.org/wiki/부동소수점</a></p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>자료구조</category>
      
    </categories>
    
    
    <tags>
      
      <tag>부동소수점</tag>
      
      <tag>float</tag>
      
      <tag>자료구조</tag>
      
      <tag>data type</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Agent 기록 제거에 대한 오해</title>
    <link href="/2016/03/sql-agent-sp-purge-jobhistory/"/>
    <url>/2016/03/sql-agent-sp-purge-jobhistory/</url>
    
    <content type="html"><![CDATA[<h2 id="에이전트-기록-제거"><a href="#에이전트-기록-제거" class="headerlink" title="에이전트 기록 제거"></a>에이전트 기록 제거</h2><p>SQL Server Management Studio (SSMS) 에서 “SQL Server 에이전트” 의 기록을 어느 정도(?) 관리할 수 있도록 되어 있습니다.</p><p>“에이전트 기록 제거” 체크를 앞으로의 기록을 자동적으로 제거하는 설정으로 오해를 하신 분들이 있을 수 있겠다 싶어 포스팅 하게 되었습니다. 실제로 제가 그런줄 알았었지요. 😝</p><p><img src="/../img/sp_purge-2016-03/agent01.png"></p><p><img src="/../img/sp_purge-2016-03/agent03.png"></p><h2 id="오해"><a href="#오해" class="headerlink" title="오해"></a>오해</h2><p>기록 페이지를 보면, “에이전트 기록 제거” 체크가 있습니다. 여기서 약간의 오해를 할 수 있는 부분이 있는데요. “에이전트 기록 제거” 체크를 하면 다음보다 오래된 항목 기준(예:4주)의 기록들을 앞으로도 계속 자동으로 제거하게 하는 설정이라고 오해할만한 소지가 있습니다.</p><p>“에이전트 기록 제거” 체크를 하고 상단에 “스크립트” 버튼을 눌러보면 아래와 같이 쿼리가 나오게 됩니다.</p><p><img src="/../img/sp_purge-2016-03/agent02.png"></p><p>msdb 안에 있는 sp_purge_jobhistory 라는 sp 를 sp_helptext 로 까보면 “다음보다 오래된 항목” 조건에 해당하는 msdb.dbo.sysjobhistory 를 delete 하는것을 확인할 수 있습니다.</p><p>즉, 현재 상황에서 기준에 해당하는 기록을 지우는 것이지, 향후에 생성될 기록들에 대한 제거 예약 작업은 아니라는 것 입니다.</p><h2 id="job-실행-기록을-자동으로-지우고-싶다면"><a href="#job-실행-기록을-자동으로-지우고-싶다면" class="headerlink" title="job 실행 기록을 자동으로 지우고 싶다면"></a>job 실행 기록을 자동으로 지우고 싶다면</h2><p>기록을 자동으로 지우고자 한다면 아래의 쿼리를 실행하는 별도의 job 을 등록해야할 것 입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@date</span> datetime;<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@date</span> <span class="hljs-operator">=</span> dateadd(<span class="hljs-keyword">month</span>, <span class="hljs-number">-1</span>, getdate());<br><br><span class="hljs-comment">-- @date 보다 오래된 msdb.dbo.sysjobhistory 를 delete</span><br><span class="hljs-keyword">exec</span> msdb.dbo.sp_purge_jobhistory <span class="hljs-variable">@oldest_date</span> <span class="hljs-operator">=</span> <span class="hljs-variable">@date</span>;<br></code></pre></td></tr></table></figure><p>이상으로 자기 혼자 오해해놓고 제목은 엄청 심오하게 써놓은 낚시성 포스팅을 마치겠습니다.</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL Agent 기록 제거</tag>
      
      <tag>sp_purge_jobhistory</tag>
      
      <tag>SSMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Server 분산 트랜잭션</title>
    <link href="/2015/11/ms-dtc/"/>
    <url>/2015/11/ms-dtc/</url>
    
    <content type="html"><![CDATA[<h2 id="DTC-개념"><a href="#DTC-개념" class="headerlink" title="DTC 개념"></a>DTC 개념</h2><p>우리는 종종 물리적으로 분리되어 있는 이기종 (또는 동종) DBMS 간에 트랜잭션 처리를 하고 싶을 수 있습니다. 이럴때 분산 트랜잭션 처리라는걸 해야 합니다.<br>(Distributed Transaction Coordinator, 이하 DTC)</p><p>아래 URL에서 도식화 되어 있는 그림을 보시면 서비스가 어떻게 구성되어야 하는지 이해 하는데에 도움이 되실겁니다.</p><p>출처: <a href="https://etutorials.org/SQL/microsoft+sql+server+2000/Part+IV+Transact-SQL/Chapter+32.+Distributed+Transaction+Processing/MS+DTC+Architecture/">https://etutorials.org/SQL/microsoft+sql+server+2000/Part+IV+Transact-SQL/Chapter+32.+Distributed+Transaction+Processing/MS+DTC+Architecture/</a></p><p><img src="/img/ms-dtc-2015-11/32fig07.gif"></p><h2 id="현재-처한-상황"><a href="#현재-처한-상황" class="headerlink" title="현재 처한 상황"></a>현재 처한 상황</h2><p>가산IDC에 회원DB 가 있고, 구로IDC에 마일리지DB 가 있고, 서초IDC에 메인DB 가 있다고 칩시다. 고객님이 인터넷에서 “결제”를 눌렀을때 일어날 수 있는 트랜잭션을 상상해봅시다. 트랜잭션 처리가 제대로 안된다면 발생할 수 있는 불상사는 굉장히 많겠지요ㅠ</p><h2 id="DTC를-위한-준비"><a href="#DTC를-위한-준비" class="headerlink" title="DTC를 위한 준비"></a>DTC를 위한 준비</h2><p>굉장히 거창해보이고 어려워보이는 MS-DTC 간단하게 설정해보고 테스트 해봅시다. 최초 client의 요청이 시작되는 서버를 메인 이라고 하고, 메인 에 등록된 링크드서버를 서브 라고 하겠습니다. 둘 다 DBMS 는 MS-SQL 이구요.</p><p>&lt;필수사항&gt;</p><ol><li>메인 에서 서브를 “연결된서버” 등록이 되어 있어야 합니다. (너무 당연한 얘기)</li><li>메인, 서브 모두 “네트워크 DTC 액세스” 가 켜있어야 합니다.</li><li>두 서버 간 DTC 관련된 방화벽 정책이 오픈되어 있어야 합니다.</li></ol><ul><li><input checked="" disabled="" type="checkbox"> DTC(Distributed Transaction Coordinator)(TCP-In)</li><li><input checked="" disabled="" type="checkbox"> DTC(Distributed Transaction Coordinator)(TCP-Out)</li></ul><p>(메인, 서브 모두) “네트워크 DTC 액세스” 열기 : 제어판 &gt; 관리 도구 &gt; 구성 요소 서비스</p><p><img src="/img/ms-dtc-2015-11/1.png"></p><p>로컬 DTC &gt; 속성 클릭네트워크 DTC 액세스 체크, 인바운드 허용 체크, 아웃바운드 허용 체크 하고 확인<br>(메인, 서브 모두) SQL서비스를 재시작합니다.</p><p><img src="/img/ms-dtc-2015-11/2.png"></p><p>이제 방화벽을 설정합니다.<br>DTC(Distributed Transaction Coordinator)(TCP-In) 규칙사용 (프로필 : 개인,공용,도메인)<br><img src="/img/ms-dtc-2015-11/3.png"></p><p>DTC(Distributed Transaction Coordinator)(TCP-Out) 규칙사용 (프로필 : 개인,공용,도메인)<br><img src="/img/ms-dtc-2015-11/4.png"></p><h2 id="Distibution-transaction-test"><a href="#Distibution-transaction-test" class="headerlink" title="Distibution transaction test"></a>Distibution transaction test</h2><p>자, 이제 실제로 쿼리를 날려보겠습니다.</p><p><img src="/img/ms-dtc-2015-11/5.png"></p><p>메인 과 서브 에 모두 데이터 반영이 잘되었을겁니다. 위에서 빨간줄 친 부분을 주의깊게 보실 필요가 있는데요.</p><p><img src="/img/ms-dtc-2015-11/6.png"></p><p>SET XACT_ABORT OFF 로 하면 무결성에 문제가 생기게 되므로 무조건 에러를 반환하는군요.  </p><p>참고:</p><p>BEGIN DISTRIBUTED TRAN 는 분산 트랜잭션을 BEGIN 시켜주는 syntax 입니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>분산 트랜잭션 테스트를 하면서 개인적으로 아리송 했던 점은 2가지 였습니다.</p><ol><li>메인, 서브 모두 MS-DTC 가 켜있어야 하는가? -&gt; <code>켜있어야 하구요.</code></li><li>MS-DTC 를 켠 이후에 SQL 서비스를 재시작하지 않으면 “활성 트랜잭션이 없습니다.” 오류를 반환하기 때문에 SQL 서비스를 재시작 했습니다.</li></ol><p>이상 허접한 포스팅을 마치겠습니다.</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MS-DTC</tag>
      
      <tag>Distribution Transaction</tag>
      
      <tag>DTC</tag>
      
      <tag>분산 트랜잭션</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MS SQL Server Repeatable Read Isolation Level</title>
    <link href="/2015/11/mssql-repeatable-read/"/>
    <url>/2015/11/mssql-repeatable-read/</url>
    
    <content type="html"><![CDATA[<h2 id="Repeatable-read-isolation-lavel"><a href="#Repeatable-read-isolation-lavel" class="headerlink" title="Repeatable read isolation lavel"></a>Repeatable read isolation lavel</h2><p>SQL Server의 repeatable read isolation lavel 이 궁금해서 테스트 해봤습니다. (반복 읽기)</p><p>일단 테이블 만들구요. insert 명령을 3번 실행해보겠습니다. (GO 3)</p><p><img src="/../img/repeatable-read-2015-11/001.png"></p><p>아래와 같이 데이터가 담겨 있습니다.</p><p><img src="/../img/repeatable-read-2015-11/002.png"></p><hr><p>먼저 세션1 에서,</p><p><img src="/../img/repeatable-read-2015-11/003.png"></p><p>위 쿼리를 실행하면 아래처럼 조회가 되겠지요.</p><p><img src="/../img/repeatable-read-2015-11/004.png"></p><p>SP_LOCK 를 통해서 확인해보면 아래와 같이 페이지, 테이블은 IS(내재된공유), 키는 S(공유)가 된 것을 확인할 수 있습니다.</p><p><img src="/../img/repeatable-read-2015-11/005.png"></p><hr><p>그럼 이제 세션2 에서,</p><p><img src="/../img/repeatable-read-2015-11/006.png"></p><p>동일한 자원의 동일한 키에 대해 UPDATE 를 시도하면?<br>☞ 해당 자원의 업데이트 잠금(mode : U)을 획득하지 못하여 무한루프에 빠지게 됩니다.</p><p>즉, Repeatable read 격리 수준 에서는<br>세션1 에서 SELECT 를 통한 공유잠금(MODE : S) 이지만<br>세션1 이 COMMIT 또는 ROLLBACK 되기 전까지는<br>세션2 의 UPDATE 를 허용하지 않습니다.<br>세션1 의 SELECT 는 반복적 (repeatable)으로 가능한 상황이지요.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>다시 정리해보자면,<br><code>한 세션의 트랜잭션이 진행 중일 때는 외부에서 데이터의 변경을 차단하고 동일한 세션에서는 동일한 데이터를 계속 읽을수 있는 구조가 필요할 때</code> 활용 가능한 격리 수준이 되겠습니다.</p><p>외부로부터의 UPDATE에 대한 트랜잭션으로 부터 잠금이 획득되지만 데이터의 INSERT 까지는 차단되지 않습니다.</p><p>SELECT 한 결과가 항상 동일하다는 것은 아니다 라는 것은 주의해야 겠네요.</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Repeatable read</tag>
      
      <tag>SQL Server isolation level</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2015/09/hello-world/"/>
    <url>/2015/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>test posting</tag>
      
      <tag>hexo</tag>
      
      <tag>Fluid theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>연습 삼아 작성해보는 첫번째 포스트</title>
    <link href="/2015/09/my-first-post/"/>
    <url>/2015/09/my-first-post/</url>
    
    <content type="html"><![CDATA[<h1 id="대제목-첫번째-대제목"><a href="#대제목-첫번째-대제목" class="headerlink" title="대제목 - 첫번째 대제목"></a>대제목 - 첫번째 대제목</h1><h2 id="중제목-블로그-개설"><a href="#중제목-블로그-개설" class="headerlink" title="중제목 - 블로그 개설"></a>중제목 - 블로그 개설</h2><p>Hello World!</p><p>rokag3-gb.github.io 블로그를 개설하였습니다.</p><p>Hugo에서 Hexo로 변경했고, 테마 적용하는 부분부터 모르겠군요.</p><p>Fluid 테마를 적용하고 처음 생성한 포스트 입니다.</p><p><a href="https://rokag3-gb.github.io/">이 하이퍼링크를 누르면 현재 페이지에서 바로 이동합니다.</a></p><h2 id="markdown-연습"><a href="#markdown-연습" class="headerlink" title="markdown 연습"></a>markdown 연습</h2><h3 id="이미지"><a href="#이미지" class="headerlink" title="이미지"></a>이미지</h3><p><img src="/img/GitHub-Logo-history-500x428.jpg"></p><h3 id="인용구-리스트-체크박스-폰트-code-block"><a href="#인용구-리스트-체크박스-폰트-code-block" class="headerlink" title="인용구, 리스트, 체크박스, 폰트, code block"></a>인용구, 리스트, 체크박스, 폰트, code block</h3><blockquote><p>인용구 테스트<br>인용구 테스트 두번째 줄</p></blockquote><p>리스트 &amp; 체크박스 테스트</p><ul><li><input checked="" disabled="" type="checkbox"> 항목 1번<ul><li><input disabled="" type="checkbox"> 1.1 세부항목</li><li><input checked="" disabled="" type="checkbox"> 1.2 세부항목</li></ul></li><li><input checked="" disabled="" type="checkbox"> 항목 2번<ul><li>2.1 세부항목</li><li>2.2 세부항목<ul><li>2.2.1 블라블라</li><li>2.2.2</li></ul></li><li><input disabled="" type="checkbox"> 2.3 세부항목</li></ul></li><li><input disabled="" type="checkbox"> 항목 3번<ul><li><input disabled="" type="checkbox"> 3.1 이렇게 체크박스를 리스트 안에 넣을 수 있습니다.</li></ul></li></ul><hr><p><em>이탤릭</em> 은 underscore(_)를 앞뒤로 묶어주고,<br><strong>볼드체</strong> 은 ** 을 앞뒤로 묶어주고,<br><del>취소선</del> 은 ~~ 을 앞뒤로 묶어주면 됩니다.</p><p><code>code block</code> 은 grave(물결표시 아래 작은따옴표) 로 묶어주면 됩니다.</p><h3 id="C-NET-syntax-highlight"><a href="#C-NET-syntax-highlight" class="headerlink" title="C#.NET syntax highlight"></a>C#.NET syntax highlight</h3><p>C# 소스코드 샘플 입니다.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// C#.NET syntax highlight sample</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">myapp</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span>  The main entry point for the application.</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        [<span class="hljs-meta">STAThread</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            ApplicationConfiguration.Initialize();<br><br>            Application.Run(<span class="hljs-keyword">new</span> Form1());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SQL-syntax-highlight"><a href="#SQL-syntax-highlight" class="headerlink" title="SQL syntax highlight"></a>SQL syntax highlight</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/* SQL syntax highlight sample */</span><br><span class="hljs-function"><span class="hljs-keyword">select</span>  <span class="hljs-title">getdate</span>()</span>;<br><br>-- 한줄 주석<br><span class="hljs-keyword">select</span>  *<br><span class="hljs-keyword">from</span>  dbo.Deal<br><span class="hljs-keyword">where</span> 거래일 between <span class="hljs-string">&#x27;2013-01-01&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;2013-12-31&#x27;</span>;<br>&#123;&#123;&lt; /highlight &gt;&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><table><thead><tr><th>col1</th><th>col2</th><th>col3</th></tr></thead><tbody><tr><td>value1</td><td>value2</td><td>value3</td></tr></tbody></table><p>흠 table은 조금 별로군요.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate; hexo server<br></code></pre></td></tr></table></figure><h3 id="코드-조각"><a href="#코드-조각" class="headerlink" title="코드 조각"></a>코드 조각</h3><p>몇가지 코드 조각을 넣는 테스트 입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  getdate();<br><br><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span>    dbo.Tenant<br><span class="hljs-keyword">where</span>   isActive <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><p>마크다운에서 Table 삽입 테스트 입니다.</p><table><thead><tr><th>column A</th><th align="right">column B</th></tr></thead><tbody><tr><td>A</td><td align="right">1000000</td></tr><tr><td>B</td><td align="right">300000</td></tr><tr><td>C</td><td align="right">1300000</td></tr><tr><td>D</td><td align="right">2006000</td></tr></tbody></table><h3 id="하이퍼링크"><a href="#하이퍼링크" class="headerlink" title="하이퍼링크"></a>하이퍼링크</h3><p><a href="https://hexo.fluid-dev.com/posts/hello-fluid/">https://hexo.fluid-dev.com/posts/hello-fluid/</a></p><p><a href="https://fluid.s3.bitiful.net/hello-fluid/cover.png?w=480&fmt=webp">https://fluid.s3.bitiful.net/hello-fluid/cover.png?w=480&amp;fmt=webp</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>first</tag>
      
      <tag>test posting</tag>
      
      <tag>hexo</tag>
      
      <tag>Fluid theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
